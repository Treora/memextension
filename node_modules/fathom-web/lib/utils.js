'use strict';

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [walk, inlineTexts].map(_regenerator2.default.mark);

var _require = require('wu'),
    flatten = _require.flatten,
    forEach = _require.forEach,
    map = _require.map;

function identity(x) {
    return x;
}

// From an iterable return the best item, according to an arbitrary comparator
// function. In case of a tie, the first item wins.
function best(iterable, by, isBetter) {
    var bestSoFar = void 0,
        bestKeySoFar = void 0;
    var isFirst = true;
    forEach(function (item) {
        var key = by(item);
        if (isBetter(key, bestKeySoFar) || isFirst) {
            bestSoFar = item;
            bestKeySoFar = key;
            isFirst = false;
        }
    }, iterable);
    if (isFirst) {
        throw new Error('Tried to call best() on empty iterable');
    }
    return bestSoFar;
}

// Return the maximum item from an iterable, as defined by >.
//
// Works with any type that works with >. If multiple items are equally great,
// return the first.
//
// by: a function that, given an item of the iterable, returns a value to
//     compare
function max(iterable) {
    var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;

    return best(iterable, by, function (a, b) {
        return a > b;
    });
}

function min(iterable) {
    var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;

    return best(iterable, by, function (a, b) {
        return a < b;
    });
}

// Return the sum of an iterable, as defined by the + operator.
function sum(iterable) {
    var total = void 0;
    var isFirst = true;
    forEach(function assignOrAdd(addend) {
        if (isFirst) {
            total = addend;
            isFirst = false;
        } else {
            total += addend;
        }
    }, iterable);
    return total;
}

function length(iterable) {
    var num = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(iterable), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            num++;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return num;
}

// Iterate, depth first, over a DOM node. Return the original node first.
// shouldTraverse - a function on a node saying whether we should include it
//     and its children
function walk(element, shouldTraverse) {
    var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, child, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, w;

    return _regenerator2.default.wrap(function walk$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    _context.next = 2;
                    return element;

                case 2:
                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;
                    _context.prev = 5;
                    _iterator2 = (0, _getIterator3.default)(element.childNodes);

                case 7:
                    if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                        _context.next = 39;
                        break;
                    }

                    child = _step2.value;

                    if (!shouldTraverse(child)) {
                        _context.next = 36;
                        break;
                    }

                    _iteratorNormalCompletion3 = true;
                    _didIteratorError3 = false;
                    _iteratorError3 = undefined;
                    _context.prev = 13;
                    _iterator3 = (0, _getIterator3.default)(walk(child, shouldTraverse));

                case 15:
                    if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                        _context.next = 22;
                        break;
                    }

                    w = _step3.value;
                    _context.next = 19;
                    return w;

                case 19:
                    _iteratorNormalCompletion3 = true;
                    _context.next = 15;
                    break;

                case 22:
                    _context.next = 28;
                    break;

                case 24:
                    _context.prev = 24;
                    _context.t0 = _context['catch'](13);
                    _didIteratorError3 = true;
                    _iteratorError3 = _context.t0;

                case 28:
                    _context.prev = 28;
                    _context.prev = 29;

                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }

                case 31:
                    _context.prev = 31;

                    if (!_didIteratorError3) {
                        _context.next = 34;
                        break;
                    }

                    throw _iteratorError3;

                case 34:
                    return _context.finish(31);

                case 35:
                    return _context.finish(28);

                case 36:
                    _iteratorNormalCompletion2 = true;
                    _context.next = 7;
                    break;

                case 39:
                    _context.next = 45;
                    break;

                case 41:
                    _context.prev = 41;
                    _context.t1 = _context['catch'](5);
                    _didIteratorError2 = true;
                    _iteratorError2 = _context.t1;

                case 45:
                    _context.prev = 45;
                    _context.prev = 46;

                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }

                case 48:
                    _context.prev = 48;

                    if (!_didIteratorError2) {
                        _context.next = 51;
                        break;
                    }

                    throw _iteratorError2;

                case 51:
                    return _context.finish(48);

                case 52:
                    return _context.finish(45);

                case 53:
                case 'end':
                    return _context.stop();
            }
        }
    }, _marked[0], this, [[5, 41, 45, 53], [13, 24, 28, 36], [29,, 31, 35], [46,, 48, 52]]);
}

var blockTags = new _set2.default();
forEach(blockTags.add.bind(blockTags), ['ADDRESS', 'BLOCKQUOTE', 'BODY', 'CENTER', 'DIR', 'DIV', 'DL', 'FIELDSET', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR', 'ISINDEX', 'MENU', 'NOFRAMES', 'NOSCRIPT', 'OL', 'P', 'PRE', 'TABLE', 'UL', 'DD', 'DT', 'FRAMESET', 'LI', 'TBODY', 'TD', 'TFOOT', 'TH', 'THEAD', 'TR', 'HTML']);
// Return whether a DOM element is a block element by default (rather
// than by styling).
function isBlock(element) {
    return blockTags.has(element.tagName);
}

// Yield strings of text nodes within a normalized DOM node and its
// children, without venturing into any contained block elements.
//
// shouldTraverse: A function that specifies additional elements to
//     exclude by returning false
function inlineTexts(element) {
    var shouldTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (element) {
        return true;
    };

    var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, child;

    return _regenerator2.default.wrap(function inlineTexts$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    // TODO: Could we just use querySelectorAll() with a really long
                    // selector rather than walk(), for speed?
                    _iteratorNormalCompletion4 = true;
                    _didIteratorError4 = false;
                    _iteratorError4 = undefined;
                    _context2.prev = 3;
                    _iterator4 = (0, _getIterator3.default)(walk(element, function (element) {
                        return !(isBlock(element) || element.tagName === 'SCRIPT' && element.tagName === 'STYLE') && shouldTraverse(element);
                    }));

                case 5:
                    if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                        _context2.next = 13;
                        break;
                    }

                    child = _step4.value;

                    if (!(child.nodeType === child.TEXT_NODE)) {
                        _context2.next = 10;
                        break;
                    }

                    _context2.next = 10;
                    return child.textContent;

                case 10:
                    _iteratorNormalCompletion4 = true;
                    _context2.next = 5;
                    break;

                case 13:
                    _context2.next = 19;
                    break;

                case 15:
                    _context2.prev = 15;
                    _context2.t0 = _context2['catch'](3);
                    _didIteratorError4 = true;
                    _iteratorError4 = _context2.t0;

                case 19:
                    _context2.prev = 19;
                    _context2.prev = 20;

                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }

                case 22:
                    _context2.prev = 22;

                    if (!_didIteratorError4) {
                        _context2.next = 25;
                        break;
                    }

                    throw _iteratorError4;

                case 25:
                    return _context2.finish(22);

                case 26:
                    return _context2.finish(19);

                case 27:
                case 'end':
                    return _context2.stop();
            }
        }
    }, _marked[1], this, [[3, 15, 19, 27], [20,, 22, 26]]);
}

function inlineTextLength(element) {
    var shouldTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (element) {
        return true;
    };

    return sum(map(function (text) {
        return collapseWhitespace(text).length;
    }, inlineTexts(element, shouldTraverse)));
}

function collapseWhitespace(str) {
    return str.replace(/\s{2,}/g, ' ');
}

// Return the ratio of the inline text length of the links in an
// element to the inline text length of the entire element.
function linkDensity(node) {
    var length = node.flavors.get('paragraphish').inlineLength;
    var lengthWithoutLinks = inlineTextLength(node.element, function (element) {
        return element.tagName !== 'A';
    });
    return (length - lengthWithoutLinks) / length;
}

// Return the next sibling node of `element`, skipping over text nodes that
// consist wholly of whitespace.
function isWhitespace(element) {
    return element.nodeType === element.TEXT_NODE && element.textContent.trim().length === 0;
}

// Return the number of stride nodes between 2 DOM nodes *at the same
// level of the tree*, without going up or down the tree.
//
// Stride nodes are {(1) siblings or (2) siblings of ancestors} that lie
// between the 2 nodes. These interposed nodes make it less likely that the 2
// nodes should be together in a cluster.
//
// left xor right may also be undefined.
function numStrides(left, right) {
    var num = 0;

    // Walk right from left node until we hit the right node or run out:
    var sibling = left;
    var shouldContinue = sibling && sibling !== right;
    while (shouldContinue) {
        sibling = sibling.nextSibling;
        if ((shouldContinue = sibling && sibling !== right) && !isWhitespace(sibling)) {
            num += 1;
        }
    }
    if (sibling !== right) {
        // Don't double-punish if left and right are siblings.
        // Walk left from right node:
        sibling = right;
        while (sibling) {
            sibling = sibling.previousSibling;
            if (sibling && !isWhitespace(sibling)) {
                num += 1;
            }
        }
    }
    return num;
}

// Return a distance measurement between 2 DOM nodes.
//
// I was thinking of something that adds little cost for siblings.
// Up should probably be more expensive than down (see middle example in the Nokia paper).
// O(n log n)
function distance(elementA, elementB) {
    // TODO: Test and tune these costs. They're off-the-cuff at the moment.
    //
    // Cost for each level deeper one node is than the other below their common
    // ancestor:
    var DIFFERENT_DEPTH_COST = 2;
    // Cost for a level below the common ancestor where tagNames differ:
    var DIFFERENT_TAG_COST = 2;
    // Cost for a level below the common ancestor where tagNames are the same:
    var SAME_TAG_COST = 1;
    // Cost for each stride node between A and B:
    var STRIDE_COST = 1;

    if (elementA === elementB) {
        return 0;
    }

    // Stacks that go from the common ancestor all the way to A and B:
    var aAncestors = [elementA];
    var bAncestors = [elementB];

    var aAncestor = elementA;
    var bAncestor = elementB;

    // Ascend to common parent, stacking them up for later reference:
    while (!aAncestor.contains(elementB)) {
        aAncestor = aAncestor.parentNode;
        aAncestors.push(aAncestor);
    }

    // Make an ancestor stack for the right node too so we can walk
    // efficiently down to it:
    do {
        bAncestor = bAncestor.parentNode; // Assumes we've early-returned above if A === B.
        bAncestors.push(bAncestor);
    } while (bAncestor !== aAncestor);

    // Figure out which node is left and which is right, so we can follow
    // sibling links in the appropriate directions when looking for stride
    // nodes:
    var left = aAncestors;
    var right = bAncestors;
    // In compareDocumentPosition()'s opinion, inside implies after. Basically,
    // before and after pertain to opening tags.
    var comparison = elementA.compareDocumentPosition(elementB);
    var cost = 0;
    var mightStride = void 0;
    if (comparison & elementA.DOCUMENT_POSITION_FOLLOWING) {
        // A is before, so it could contain the other node.
        mightStride = !(comparison & elementA.DOCUMENT_POSITION_CONTAINED_BY);
        left = aAncestors;
        right = bAncestors;
    } else if (comparison & elementA.DOCUMENT_POSITION_PRECEDING) {
        // A is after, so it might be contained by the other node.
        mightStride = !(comparison & elementA.DOCUMENT_POSITION_CONTAINS);
        left = bAncestors;
        right = aAncestors;
    }

    // Descend to both nodes in parallel, discounting the traversal
    // cost iff the nodes we hit look similar, implying the nodes dwell
    // within similar structures.
    while (left.length || right.length) {
        var l = left.pop();
        var r = right.pop();
        if (l === undefined || r === undefined) {
            // Punishment for being at different depths: same as ordinary
            // dissimilarity punishment for now
            cost += DIFFERENT_DEPTH_COST;
        } else {
            // TODO: Consider similarity of classList.
            cost += l.tagName === r.tagName ? SAME_TAG_COST : DIFFERENT_TAG_COST;
        }
        // Optimization: strides might be a good dimension to eliminate.
        if (mightStride) {
            cost += numStrides(l, r) * STRIDE_COST;
        }
    }

    return cost;
}

// A lower-triangular matrix of inter-cluster distances
// TODO: Allow distance function to be passed in, making this generally useful
// and not tied to the DOM.

var DistanceMatrix = function () {
    function DistanceMatrix(elements) {
        (0, _classCallCheck3.default)(this, DistanceMatrix);

        // A sparse adjacency matrix:
        // {A => {},
        //  B => {A => 4},
        //  C => {A => 4, B => 4},
        //  D => {A => 4, B => 4, C => 4}
        //  E => {A => 4, B => 4, C => 4, D => 4}}
        //
        // A, B, etc. are arrays of [arrays of arrays of...] DOM nodes, each
        // array being a cluster. In this way, they not only accumulate a
        // cluster but retain the steps along the way.
        //
        // This is an efficient data structure in terms of CPU and memory, in
        // that we don't have to slide a lot of memory around when we delete a
        // row or column from the middle of the matrix while merging. Of
        // course, we lose some practical efficiency by using hash tables, and
        // maps in particular are slow in their early implementations.
        this._matrix = new _map2.default();

        // Convert elements to clusters:
        var clusters = elements.map(function (el) {
            return [el];
        });

        // Init matrix:
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = (0, _getIterator3.default)(clusters), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var outerCluster = _step5.value;

                var innerMap = new _map2.default();
                var _iteratorNormalCompletion6 = true;
                var _didIteratorError6 = false;
                var _iteratorError6 = undefined;

                try {
                    for (var _iterator6 = (0, _getIterator3.default)(this._matrix.keys()), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                        var innerCluster = _step6.value;

                        innerMap.set(innerCluster, distance(outerCluster[0], innerCluster[0]));
                    }
                } catch (err) {
                    _didIteratorError6 = true;
                    _iteratorError6 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion6 && _iterator6.return) {
                            _iterator6.return();
                        }
                    } finally {
                        if (_didIteratorError6) {
                            throw _iteratorError6;
                        }
                    }
                }

                this._matrix.set(outerCluster, innerMap);
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        this._numClusters = clusters.length;
    }

    // Return (distance, a: clusterA, b: clusterB) of closest-together clusters.
    // Replace this to change linkage criterion.


    (0, _createClass3.default)(DistanceMatrix, [{
        key: 'closest',
        value: function closest() {
            var _marked2 = [clustersAndDistances].map(_regenerator2.default.mark);

            var self = this;

            if (this._numClusters < 2) {
                throw new Error('There must be at least 2 clusters in order to return the closest() ones.');
            }

            // Return the distances between every pair of clusters.
            function clustersAndDistances() {
                var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _step7$value, outerKey, row, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, _step8$value, innerKey, storedDistance;

                return _regenerator2.default.wrap(function clustersAndDistances$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _iteratorNormalCompletion7 = true;
                                _didIteratorError7 = false;
                                _iteratorError7 = undefined;
                                _context3.prev = 3;
                                _iterator7 = (0, _getIterator3.default)(self._matrix.entries());

                            case 5:
                                if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
                                    _context3.next = 36;
                                    break;
                                }

                                _step7$value = (0, _slicedToArray3.default)(_step7.value, 2), outerKey = _step7$value[0], row = _step7$value[1];
                                _iteratorNormalCompletion8 = true;
                                _didIteratorError8 = false;
                                _iteratorError8 = undefined;
                                _context3.prev = 10;
                                _iterator8 = (0, _getIterator3.default)(row.entries());

                            case 12:
                                if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
                                    _context3.next = 19;
                                    break;
                                }

                                _step8$value = (0, _slicedToArray3.default)(_step8.value, 2), innerKey = _step8$value[0], storedDistance = _step8$value[1];
                                _context3.next = 16;
                                return { a: outerKey, b: innerKey, distance: storedDistance };

                            case 16:
                                _iteratorNormalCompletion8 = true;
                                _context3.next = 12;
                                break;

                            case 19:
                                _context3.next = 25;
                                break;

                            case 21:
                                _context3.prev = 21;
                                _context3.t0 = _context3['catch'](10);
                                _didIteratorError8 = true;
                                _iteratorError8 = _context3.t0;

                            case 25:
                                _context3.prev = 25;
                                _context3.prev = 26;

                                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                    _iterator8.return();
                                }

                            case 28:
                                _context3.prev = 28;

                                if (!_didIteratorError8) {
                                    _context3.next = 31;
                                    break;
                                }

                                throw _iteratorError8;

                            case 31:
                                return _context3.finish(28);

                            case 32:
                                return _context3.finish(25);

                            case 33:
                                _iteratorNormalCompletion7 = true;
                                _context3.next = 5;
                                break;

                            case 36:
                                _context3.next = 42;
                                break;

                            case 38:
                                _context3.prev = 38;
                                _context3.t1 = _context3['catch'](3);
                                _didIteratorError7 = true;
                                _iteratorError7 = _context3.t1;

                            case 42:
                                _context3.prev = 42;
                                _context3.prev = 43;

                                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                                    _iterator7.return();
                                }

                            case 45:
                                _context3.prev = 45;

                                if (!_didIteratorError7) {
                                    _context3.next = 48;
                                    break;
                                }

                                throw _iteratorError7;

                            case 48:
                                return _context3.finish(45);

                            case 49:
                                return _context3.finish(42);

                            case 50:
                            case 'end':
                                return _context3.stop();
                        }
                    }
                }, _marked2[0], this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
            }
            return min(clustersAndDistances(), function (x) {
                return x.distance;
            });
        }

        // Look up the distance between 2 clusters in me. Try the lookup in the
        // other direction if the first one falls in the nonexistent half of the
        // triangle.

    }, {
        key: '_cachedDistance',
        value: function _cachedDistance(clusterA, clusterB) {
            var ret = this._matrix.get(clusterA).get(clusterB);
            if (ret === undefined) {
                ret = this._matrix.get(clusterB).get(clusterA);
            }
            return ret;
        }

        // Merge two clusters.

    }, {
        key: 'merge',
        value: function merge(clusterA, clusterB) {
            // An example showing how rows merge:
            //  A: {}
            //  B: {A: 1}
            //  C: {A: 4, B: 4},
            //  D: {A: 4, B: 4, C: 4}
            //  E: {A: 4, B: 4, C: 2, D: 4}}
            //
            // Step 2:
            //  C: {}
            //  D: {C: 4}
            //  E: {C: 2, D: 4}}
            //  AB: {C: 4, D: 4, E: 4}
            //
            // Step 3:
            //  D:  {}
            //  AB: {D: 4}
            //  CE: {D: 4, AB: 4}

            // Construct new row, finding min distances from either subcluster of
            // the new cluster to old clusters.
            //
            // There will be no repetition in the matrix because, after all,
            // nothing pointed to this new cluster before it existed.
            var newRow = new _map2.default();
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
                for (var _iterator9 = (0, _getIterator3.default)(this._matrix.keys()), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var _outerKey = _step9.value;

                    if (_outerKey !== clusterA && _outerKey !== clusterB) {
                        newRow.set(_outerKey, Math.min(this._cachedDistance(clusterA, _outerKey), this._cachedDistance(clusterB, _outerKey)));
                    }
                }

                // Delete the rows of the clusters we're merging.
            } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }
                } finally {
                    if (_didIteratorError9) {
                        throw _iteratorError9;
                    }
                }
            }

            this._matrix.delete(clusterA);
            this._matrix.delete(clusterB);

            // Remove inner refs to the clusters we're merging.
            var _iteratorNormalCompletion10 = true;
            var _didIteratorError10 = false;
            var _iteratorError10 = undefined;

            try {
                for (var _iterator10 = (0, _getIterator3.default)(this._matrix.values()), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                    var inner = _step10.value;

                    inner.delete(clusterA);
                    inner.delete(clusterB);
                }

                // Attach new row.
            } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion10 && _iterator10.return) {
                        _iterator10.return();
                    }
                } finally {
                    if (_didIteratorError10) {
                        throw _iteratorError10;
                    }
                }
            }

            this._matrix.set([clusterA, clusterB], newRow);

            // There is a net decrease of 1 cluster:
            this._numClusters -= 1;
        }
    }, {
        key: 'numClusters',
        value: function numClusters() {
            return this._numClusters;
        }

        // Return an Array of nodes for each cluster in me.

    }, {
        key: 'clusters',
        value: function clusters() {
            // TODO: Can't get wu.map to work here. Don't know why.
            return (0, _from2.default)(this._matrix.keys()).map(function (e) {
                return (0, _from2.default)(flatten(false, e));
            });
        }
    }]);
    return DistanceMatrix;
}();

// Partition the given nodes into one or more clusters by position in the DOM
// tree.
//
// elements: An Array of DOM nodes
// tooFar: The closest-nodes distance() beyond which we will not attempt to
//     unify 2 clusters
//
// This implements an agglomerative clustering. It uses single linkage, since
// we're talking about adjacency here more than Euclidean proximity: the
// clusters we're talking about in the DOM will tend to be adjacent, not
// overlapping. We haven't tried other linkage criteria yet.
//
// Maybe later we'll consider score or notes.


function clusters(elements, tooFar) {
    var matrix = new DistanceMatrix(elements);
    var closest = void 0;

    while (matrix.numClusters() > 1 && (closest = matrix.closest()).distance < tooFar) {
        matrix.merge(closest.a, closest.b);
    }

    return matrix.clusters();
}

module.exports = {
    best: best,
    collapseWhitespace: collapseWhitespace,
    clusters: clusters,
    distance: distance,
    identity: identity,
    inlineTextLength: inlineTextLength,
    inlineTexts: inlineTexts,
    isBlock: isBlock,
    length: length,
    linkDensity: linkDensity,
    max: max,
    min: min,
    sum: sum,
    walk: walk
};