require("source-map-support").install();
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isRunFromCLI = isRunFromCLI;
	exports.createInstance = createInstance;
	
	var _cli = __webpack_require__(2);
	
	var _linter = __webpack_require__(11);
	
	var _linter2 = _interopRequireDefault(_linter);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* istanbul ignore if */
	if (!global._babelPolyfill) {
	  __webpack_require__(89);
	}
	
	function isRunFromCLI() {
	  var _module = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : module;
	
	  return __webpack_require__.c[0] === _module;
	}
	
	function createInstance() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$config = _ref.config,
	      config = _ref$config === undefined ? (0, _cli.getConfig)({ useCLI: isRunFromCLI() }).argv : _ref$config,
	      _ref$runAsBinary = _ref.runAsBinary,
	      runAsBinary = _ref$runAsBinary === undefined ? false : _ref$runAsBinary;
	
	  _logger2.default.level(config.logLevel);
	  _logger2.default.info('Creating new linter instance', { config: config });
	  config.runAsBinary = runAsBinary;
	  return new _linter2.default(config);
	}
	
	exports.default = _linter2.default;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _templateObject = _taggedTemplateLiteral(['Config requested from CLI, but not in CLI mode.\n      Please supply a config instead of relying on the getConfig() call.'], ['Config requested from CLI, but not in CLI mode.\n      Please supply a config instead of relying on the getConfig() call.']);
	
	exports.getConfig = getConfig;
	exports.terminalWidth = terminalWidth;
	
	var _yargs = __webpack_require__(3);
	
	var _yargs2 = _interopRequireDefault(_yargs);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _utils = __webpack_require__(6);
	
	var _package = __webpack_require__(10);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function getConfig() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$useCLI = _ref.useCLI,
	      useCLI = _ref$useCLI === undefined ? true : _ref$useCLI;
	
	  if (useCLI === false) {
	    _logger2.default.error((0, _utils.singleLineString)(_templateObject));
	    throw new Error('Cannot request config from CLI in library mode');
	  }
	
	  return _yargs2.default.usage('Usage: ./$0 [options] addon-package-or-dir \n\n\n      Add-ons Linter (JS Edition) v' + _package.version).option('log-level', {
	    describe: 'The log-level to generate',
	    type: 'string',
	    default: 'fatal',
	    choices: ['fatal', 'error', 'warn', 'info', 'debug', 'trace']
	  }).option('warnings-as-errors', {
	    describe: 'Treat warning as errors',
	    type: 'boolean',
	    default: false
	  }).option('output', {
	    alias: 'o',
	    describe: 'The type of output to generate',
	    type: 'string',
	    default: 'text',
	    choices: ['json', 'text']
	  }).option('metadata', {
	    describe: 'Output only metadata as JSON',
	    type: 'boolean',
	    default: 'false'
	  }).option('pretty', {
	    describe: 'Prettify JSON output',
	    type: 'boolean',
	    default: false
	  }).option('stack', {
	    describe: 'Show stacktraces when errors are thrown',
	    type: 'boolean',
	    default: false
	  }).option('boring', {
	    describe: 'Disables colorful shell output',
	    type: 'boolean',
	    default: false
	  }).option('self-hosted', {
	    describe: 'Disables messages related to hosting on addons.mozilla.org.',
	    type: 'boolean',
	    default: false
	  })
	  // Require one non-option.
	  .demand(1).help('help').alias('h', 'help').wrap(terminalWidth());
	}
	
	function terminalWidth() {
	  var _process = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process;
	
	  if (_process && _process.stdout && _process.stdout.columns > 0) {
	    var width = _process.stdout.columns - 2;
	    // Terminals less than ten pixels wide seem silly.
	    if (width < 10) {
	      width = 10;
	    }
	
	    return width;
	  } else {
	    return 78;
	  }
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("yargs");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createLogger = createLogger;
	
	var _bunyan = __webpack_require__(5);
	
	var _bunyan2 = _interopRequireDefault(_bunyan);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createLogger() {
	  var _process = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process;
	
	  var level = _process.env.LOG_LEVEL || 'fatal';
	  var logLevels = Object.keys(_bunyan2.default.levelFromName);
	  if (logLevels.indexOf(level) === -1) {
	    throw new Error('LOG_LEVEL must be one of ' + logLevels.join(', '));
	  }
	  return _bunyan2.default.createLogger({
	    name: 'AddonLinterJS',
	    stream: process.stdout,
	    level: level
	  });
	}
	
	exports.default = createLogger();

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("bunyan");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _templateObject = _taggedTemplateLiteral(['Node version must be ', ' or\n                      greater. You are using ', '.'], ['Node version must be ', ' or\n                      greater. You are using ', '.']);
	
	exports.singleLineString = singleLineString;
	exports.getRootExpression = getRootExpression;
	exports.getNodeReference = getNodeReference;
	exports.getVariable = getVariable;
	exports.gettext = gettext;
	exports.checkMinNodeVersion = checkMinNodeVersion;
	exports.getPackageTypeAsString = getPackageTypeAsString;
	exports.ignorePrivateFunctions = ignorePrivateFunctions;
	exports.ensureFilenameExists = ensureFilenameExists;
	exports.isLocalUrl = isLocalUrl;
	exports.apiToMessage = apiToMessage;
	
	var _url = __webpack_require__(7);
	
	var _url2 = _interopRequireDefault(_url);
	
	var _semver = __webpack_require__(8);
	
	var _semver2 = _interopRequireDefault(_semver);
	
	var _const = __webpack_require__(9);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	/*
	 * Template tag for removing whitespace and new lines
	 * in order to be able to use multiline template strings
	 * as a single string.
	 *
	 * Usage: singleLineString`foo bar baz
	 *                    whatever`;
	 *
	 * Will output: 'foo bar baz whatever'
	 *
	 */
	function singleLineString(strings) {
	  // Interweave the strings with the
	  // substitution vars first.
	  var output = '';
	
	  for (var _len = arguments.length, vars = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    vars[_key - 1] = arguments[_key];
	  }
	
	  for (var i = 0; i < vars.length; i++) {
	    output += strings[i] + vars[i];
	  }
	  output += strings[vars.length];
	
	  // Split on newlines.
	  var lines = output.split(/(?:\r\n|\n|\r)/);
	
	  // Rip out the leading whitespace.
	  return lines.map(function (line) {
	    return line.replace(/^\s+/gm, '');
	  }).join(' ').trim();
	}
	
	/*
	 * Takes an AST node and returns the root property.
	 *
	 * example: foo().bar.baz() will return the AST node for foo.
	 */
	function getRootExpression(node) {
	  var root = node.callee;
	
	  // If we encounter a member, grab the parent
	  if (node.callee.type === 'MemberExpression') {
	    var parent = node.callee.object;
	    while (parent.type !== 'Identifier') {
	      if (parent.callee.type === 'MemberExpression') {
	        parent = parent.callee.object;
	      } else {
	        parent = parent.callee;
	      }
	    }
	    root = parent;
	  }
	
	  return root;
	}
	
	/*
	 * Returns the name of the reference node passed.
	 *
	 * example: var foo = document;
	 *  The node for foo will return 'document'
	 */
	function getNodeReference(context, node) {
	  var variables = context.getScope().variables;
	  var scopeVar;
	
	  // Just return the value if the node passed in is a reference to a literal.
	  if (typeof node === 'undefined' || node.type === 'Literal') {
	    return node;
	  }
	
	  // Finds variable reference in current scope.
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = variables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var variable = _step.value;
	
	      if (variable.name === node.name) {
	        scopeVar = variable;
	        break;
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  if (scopeVar && scopeVar.defs && scopeVar.defs[0] && scopeVar.defs[0].parent && scopeVar.defs[0].parent.parent && scopeVar.defs[0].parent.parent.body) {
	    // This represents all occurrences of the variable
	    var occurances = scopeVar.defs[0].parent.parent.body;
	    var lastAssignment = void 0;
	
	    if (occurances instanceof Array) {
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = occurances[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var occurance = _step2.value;
	
	          if (occurance.type === 'VariableDeclaration' && occurance.declarations[0].init !== null) {
	            // Get what the name of what it was assigned to or the raw
	            // value depending on the initalization
	            lastAssignment = occurance.declarations[0].init;
	          } else if (occurance.type === 'ExpressionStatement' && occurance.expression.type === 'AssignmentExpression') {
	            // Get the right hand side of the assignment
	            lastAssignment = occurance.expression.right;
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	
	    // Return the name of the first definition of the variable which
	    // corresponds to the node passed in.
	    if (lastAssignment) {
	      return lastAssignment;
	    }
	  }
	
	  // If that variable doesn't exist in scope, then just return the node's
	  // name.
	  return node;
	}
	
	/*
	 * Get a variable from a eslint context object if it exists, otherwise
	 * undefined.
	 */
	function getVariable(context, name) {
	  var variables = context.getScope().variables;
	  var result;
	  variables.forEach(function (variable) {
	    if (variable.name === name && variable.defs && variable.defs[0] && variable.defs[0].name && variable.defs[0].name.parent) {
	      result = variable.defs[0].name.parent.init;
	    }
	  });
	  return result;
	}
	
	/*
	 * Gettext utils. No-op until we have proper
	 * a proper l10n solution.
	 *
	 */
	function gettext(str) {
	  return str;
	}
	
	/*
	 * Check the minimum node version is met
	 */
	function checkMinNodeVersion(minVersion) {
	  var _process = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process;
	
	  return new Promise(function (resolve) {
	    minVersion = minVersion || '0.12.0';
	    if (!_semver2.default.gte(_process.version, minVersion)) {
	      throw new Error(singleLineString(_templateObject, minVersion, _process.version));
	    } else {
	      resolve();
	    }
	  });
	}
	
	function getPackageTypeAsString(numericPackageType) {
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = Object.keys(_const.PACKAGE_TYPES)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var packageType = _step3.value;
	
	      if (parseInt(numericPackageType, 10) === _const.PACKAGE_TYPES[packageType]) {
	        return packageType;
	      }
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	
	  throw new Error('Invalid package type constant "' + numericPackageType + '"');
	}
	
	/*
	 * Looks through all exported functions and returns only
	 * "public" *functions* that aren't prefixed with an _
	 *
	 * Used for ignoring private functions and constants in rules files.
	 * Rules can have private functions we don't run; anything that
	 * starts with an "_" shouldn't be returned.
	 *
	 * This exists because we export private functions in rule files
	 * for testing.
	 */
	function ignorePrivateFunctions(list) {
	  var filteredList = {};
	
	  for (var functionName in list) {
	    if (functionName.startsWith('_') === false && typeof list[functionName] === 'function') {
	      filteredList[functionName] = list[functionName];
	    }
	  }
	
	  return filteredList;
	}
	
	/*
	 * Check a filename to make sure it's valid; used by scanners so we never
	 * accept new scanners that don't specify which file they're referencing.
	 */
	function ensureFilenameExists(filename) {
	  if (typeof filename !== 'string' || filename.length < 1) {
	    throw new Error('Filename is required');
	  }
	}
	
	function isLocalUrl(urlInput) {
	  var parsedUrl = _url2.default.parse(urlInput);
	  var protocol = parsedUrl.protocol;
	  var path = parsedUrl.path;
	  // Check protocol is chrome: or resource: if set.
	  // Details on the chrome protocol are here: https://goo.gl/W52T0Q
	  // Details on resource protocol are here: https://goo.gl/HHqeJA
	  if (protocol && !_const.LOCAL_PROTOCOLS.includes(protocol)) {
	    return false;
	  }
	  // Disallow protocol-free remote urls.
	  if (path.startsWith('//')) {
	    return false;
	  }
	  return true;
	}
	
	function apiToMessage(string) {
	  return string.replace(/^extension/, 'ext').replace(/\./g, '_').toUpperCase().substr(0, 25);
	}

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = require("semver");

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var DEFLATE_COMPRESSION = exports.DEFLATE_COMPRESSION = 8;
	var NO_COMPRESSION = exports.NO_COMPRESSION = 0;
	
	var ESLINT_ERROR = exports.ESLINT_ERROR = 2;
	var ESLINT_WARNING = exports.ESLINT_WARNING = 1;
	
	var ESLINT_RULE_MAPPING = exports.ESLINT_RULE_MAPPING = {
	  banned_identifiers: ESLINT_WARNING,
	  deprecated_entities: ESLINT_WARNING,
	  eval_string_arg: ESLINT_WARNING,
	  event_listener_fourth: ESLINT_WARNING,
	  global_require_arg: ESLINT_WARNING,
	  init_null_arg: ESLINT_WARNING,
	  low_level_module: ESLINT_WARNING,
	  mozindexeddb: ESLINT_WARNING,
	  mozindexeddb_property: ESLINT_WARNING,
	  only_prefs_in_defaults: ESLINT_WARNING,
	  opendialog_nonlit_uri: ESLINT_WARNING,
	  opendialog_remote_uri: ESLINT_WARNING,
	  shallow_wrapper: ESLINT_WARNING,
	  webextension_api: ESLINT_WARNING,
	  widget_module: ESLINT_WARNING
	};
	
	var VALIDATION_ERROR = exports.VALIDATION_ERROR = 'error';
	var VALIDATION_NOTICE = exports.VALIDATION_NOTICE = 'notice';
	var VALIDATION_WARNING = exports.VALIDATION_WARNING = 'warning';
	
	var ESLINT_TYPES = exports.ESLINT_TYPES = {
	  0: VALIDATION_NOTICE,
	  1: VALIDATION_WARNING,
	  2: VALIDATION_ERROR
	};
	
	var MESSAGE_TYPES = exports.MESSAGE_TYPES = [VALIDATION_ERROR, VALIDATION_NOTICE, VALIDATION_WARNING];
	
	var RDF_DEFAULT_NAMESPACE = exports.RDF_DEFAULT_NAMESPACE = 'http://www.mozilla.org/2004/em-rdf#';
	
	var RDF_UNALLOWED_TAGS = exports.RDF_UNALLOWED_TAGS = ['hidden'];
	var RDF_UNALLOWED_IF_LISTED_TAGS = exports.RDF_UNALLOWED_IF_LISTED_TAGS = ['updateKey', 'updateURL'];
	var RDF_OBSOLETE_TAGS = exports.RDF_OBSOLETE_TAGS = ['file', 'requires', 'skin'];
	
	var HTML_TAGS_WITH_REQUIRED_ATTRIBUTES = exports.HTML_TAGS_WITH_REQUIRED_ATTRIBUTES = {
	  prefwindow: ['id']
	};
	
	// Package type constants.
	var PACKAGE_ANY = exports.PACKAGE_ANY = 0;
	var PACKAGE_EXTENSION = exports.PACKAGE_EXTENSION = 1;
	var PACKAGE_THEME = exports.PACKAGE_THEME = 2;
	var PACKAGE_DICTIONARY = exports.PACKAGE_DICTIONARY = 3;
	var PACKAGE_LANGPACK = exports.PACKAGE_LANGPACK = 4;
	var PACKAGE_SEARCHPROV = exports.PACKAGE_SEARCHPROV = 5;
	var PACKAGE_MULTI = exports.PACKAGE_MULTI = 1; // A multi extension is an extension
	var PACKAGE_SUBPACKAGE = exports.PACKAGE_SUBPACKAGE = 7;
	
	var PACKAGE_TYPES = exports.PACKAGE_TYPES = {
	  PACKAGE_ANY: PACKAGE_ANY,
	  PACKAGE_EXTENSION: PACKAGE_EXTENSION,
	  PACKAGE_THEME: PACKAGE_THEME,
	  PACKAGE_DICTIONARY: PACKAGE_DICTIONARY,
	  PACKAGE_LANGPACK: PACKAGE_LANGPACK,
	  PACKAGE_SEARCHPROV: PACKAGE_SEARCHPROV,
	  PACKAGE_MULTI: PACKAGE_MULTI,
	  PACKAGE_SUBPACKAGE: PACKAGE_SUBPACKAGE
	};
	
	// Types from install.rdf don't match the types
	// we use internally. This provides a mapping.
	var ADDON_TYPE_MAP = exports.ADDON_TYPE_MAP = {
	  2: PACKAGE_EXTENSION,
	  4: PACKAGE_THEME,
	  8: PACKAGE_LANGPACK,
	  32: PACKAGE_MULTI,
	  64: PACKAGE_DICTIONARY,
	  // New "experiment" type: see bug 1220097
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=1220583
	  128: PACKAGE_EXTENSION
	};
	
	var LOCAL_PROTOCOLS = exports.LOCAL_PROTOCOLS = ['chrome:', 'resource:'];
	
	// If you add to this you'll need to additionally
	// update _BANNED_IDENTIFIERS_MAP with details in
	// messages/javascript.
	var BANNED_IDENTIFIERS = exports.BANNED_IDENTIFIERS = ['newThread', 'processNextEvent'];
	
	var LOW_LEVEL_MODULES = exports.LOW_LEVEL_MODULES = [
	// Added from bugs 689340, 731109
	'chrome', 'window-utils', 'observer-service',
	// Added from bug 845492
	'window/utils', 'sdk/window/utils', 'sdk/deprecated/window-utils', 'tab/utils', 'sdk/tab/utils', 'system/events', 'sdk/system/events'];
	
	var INSTALL_RDF = exports.INSTALL_RDF = 'install.rdf';
	var MANIFEST_JSON = exports.MANIFEST_JSON = 'manifest.json';
	var CHROME_MANIFEST = exports.CHROME_MANIFEST = 'chrome.manifest';
	
	var VALID_MANIFEST_VERSION = exports.VALID_MANIFEST_VERSION = 2;
	
	// The max file size in MB that the
	// io classes will open as strings or streams.
	var MAX_FILE_SIZE_MB = exports.MAX_FILE_SIZE_MB = 100;
	// This is the limit in megabytes of a file we will parse (eg. CSS, JS, etc.)
	// A singular CSS/JS file over 4MB seems bad and may actually be full of data
	// best stored in JSON/some other data format rather than code.
	// https://github.com/mozilla/addons-linter/issues/730
	// We increased this limit from 2MB to 4MB as per:
	// https://github.com/mozilla/addons/issues/181
	//
	// We should be careful about increasing this any further.
	var MAX_FILE_SIZE_TO_PARSE_MB = exports.MAX_FILE_SIZE_TO_PARSE_MB = 4;
	
	var HIDDEN_FILE_REGEX = exports.HIDDEN_FILE_REGEX = /^__MACOSX\//;
	var FLAGGED_FILE_REGEX = exports.FLAGGED_FILE_REGEX = /thumbs\.db$|\.DS_Store$|\.orig$|\.old$|\~$/i;
	var ALREADY_SIGNED_REGEX = exports.ALREADY_SIGNED_REGEX = /^META\-INF\/manifest\.mf/;
	
	var FLAGGED_FILE_EXTENSION_REGEX = exports.FLAGGED_FILE_EXTENSION_REGEX = /\.exe$|\.dll$|\.dylib$|\.so$|\.sh$|\.class$|\.swf$/i;
	
	// A list of magic numbers that we won't allow.
	var FLAGGED_FILE_MAGIC_NUMBERS = exports.FLAGGED_FILE_MAGIC_NUMBERS = [[0x4d, 0x5a], // EXE or DLL,
	[0x5a, 0x4d], // Alternative EXE or DLL
	[0x7f, 0x45, 0x4c, 0x46], // UNIX elf
	[0x23, 0x21], // Shell script
	[0xca, 0xfe, 0xba, 0xbe], // Java + Mach-O (dylib)
	[0xca, 0xfe, 0xd0, 0x0d], // Java packed
	[0x43, 0x57, 0x53]];
	
	// Based on the above, this is how deep we need to look into a file.
	var FLAGGED_FILE_MAGIC_NUMBERS_LENGTH = exports.FLAGGED_FILE_MAGIC_NUMBERS_LENGTH = 4;
	
	var DEPRECATED_APIS = exports.DEPRECATED_APIS = ['app.getDetails', 'extension.onRequest', 'extension.onRequestExternal', 'extension.sendRequest', 'tabs.getAllInWindow', 'tabs.getSelected', 'tabs.onActiveChanged', 'tabs.onSelectionChanged', 'tabs.sendRequest'];
	
	// These are APIs that will cause problems when loaded temporarily
	// in about:debugging.
	var TEMPORARY_APIS = exports.TEMPORARY_APIS = ['identity.getRedirectURL', 'storage.local', 'storage.sync'];

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = {
		"name": "addons-linter",
		"version": "0.15.15",
		"description": "Mozilla Add-ons Linter",
		"main": "dist/addons-linter.js",
		"bin": {
			"addons-linter": "bin/addons-linter"
		},
		"scripts": {
			"start": "grunt start",
			"build": "grunt build",
			"test": "grunt test",
			"test-no-coverage": "grunt test-no-coverage",
			"publish-rules": "grunt copy build-rules-html publish-rules",
			"publish-coverage": "grunt coveralls"
		},
		"repository": {
			"type": "git",
			"url": "git+https://github.com/mozilla/addons-linter.git"
		},
		"author": "Mozilla Add-ons Team",
		"license": "MPL-2.0",
		"bugs": {
			"url": "https://github.com/mozilla/addons-linter/issues"
		},
		"homepage": "https://github.com/mozilla/addons-linter#readme",
		"devDependencies": {
			"babel-core": "6.21.0",
			"babel-eslint": "7.1.0",
			"babel-istanbul": "0.12.1",
			"babel-istanbul-loader": "0.1.0",
			"babel-loader": "6.2.10",
			"babel-plugin-transform-class-properties": "6.18.0",
			"babel-plugin-transform-es2015-modules-commonjs": "6.18.0",
			"babel-preset-es2015": "6.18.0",
			"babel-preset-stage-2": "6.18.0",
			"chai": "3.5.0",
			"coveralls": "2.11.15",
			"gfm.css": "1.1.1",
			"grunt": "1.0.1",
			"grunt-contrib-clean": "1.0.0",
			"grunt-contrib-copy": "1.0.0",
			"grunt-coveralls": "1.0.1",
			"grunt-eslint": "19.0.0",
			"grunt-gh-pages": "2.0.0",
			"grunt-mocha-test": "0.13.2",
			"grunt-newer": "1.2.0",
			"grunt-webpack": "1.0.18",
			"isparta": "4.0.0",
			"json-loader": "0.5.4",
			"load-grunt-configs": "1.0.0",
			"load-grunt-tasks": "3.5.2",
			"lodash.clonedeep": "4.5.0",
			"markdown-it": "8.2.2",
			"markdown-it-anchor": "2.6.0",
			"markdown-it-emoji": "1.3.0",
			"mocha": "3.1.2",
			"mocha-multi": "0.10.0",
			"shelljs": "0.7.5",
			"sinon": "1.17.7",
			"webpack": "1.14.0",
			"webpack-dev-server": "1.16.2"
		},
		"dependencies": {
			"ajv": "4.10.4",
			"babel-polyfill": "6.20.0",
			"bunyan": "1.8.5",
			"chalk": "1.1.3",
			"cheerio": "0.22.0",
			"columnify": "1.5.4",
			"crx-parser": "0.1.2",
			"dispensary": "0.10.3",
			"es6-promisify": "5.0.0",
			"eslint": "3.13.1",
			"esprima": "3.1.3",
			"first-chunk-stream": "2.0.0",
			"postcss": "5.2.10",
			"relaxed-json": "1.0.0",
			"semver": "5.3.0",
			"source-map-support": "0.4.7",
			"strip-bom-stream": "2.0.0",
			"url-parse": "1.1.7",
			"xmldom": "0.1.22",
			"yargs": "6.6.0",
			"yauzl": "2.7.0"
		}
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['colorize passed invalid type.\n          Should be one of ', ''], ['colorize passed invalid type.\n          Should be one of ', '']),
	    _templateObject2 = _taggedTemplateLiteral(['No ', ' or ', '\n                   was found in the package metadata'], ['No ', ' or ', '\n                   was found in the package metadata']);
	
	var _path = __webpack_require__(12);
	
	var _columnify = __webpack_require__(13);
	
	var _columnify2 = _interopRequireDefault(_columnify);
	
	var _chalk = __webpack_require__(14);
	
	var _chalk2 = _interopRequireDefault(_chalk);
	
	var _dispensary = __webpack_require__(15);
	
	var _dispensary2 = _interopRequireDefault(_dispensary);
	
	var _utils = __webpack_require__(16);
	
	var _cli = __webpack_require__(2);
	
	var _const = __webpack_require__(9);
	
	var constants = _interopRequireWildcard(_const);
	
	var _libraries = __webpack_require__(19);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _utils2 = __webpack_require__(6);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _collector = __webpack_require__(29);
	
	var _collector2 = _interopRequireDefault(_collector);
	
	var _installrdf = __webpack_require__(31);
	
	var _installrdf2 = _interopRequireDefault(_installrdf);
	
	var _manifestjson = __webpack_require__(32);
	
	var _manifestjson2 = _interopRequireDefault(_manifestjson);
	
	var _binary = __webpack_require__(41);
	
	var _binary2 = _interopRequireDefault(_binary);
	
	var _chromemanifest = __webpack_require__(43);
	
	var _chromemanifest2 = _interopRequireDefault(_chromemanifest);
	
	var _css = __webpack_require__(48);
	
	var _css2 = _interopRequireDefault(_css);
	
	var _filename = __webpack_require__(52);
	
	var _filename2 = _interopRequireDefault(_filename);
	
	var _html = __webpack_require__(53);
	
	var _html2 = _interopRequireDefault(_html);
	
	var _javascript = __webpack_require__(57);
	
	var _javascript2 = _interopRequireDefault(_javascript);
	
	var _json = __webpack_require__(75);
	
	var _json2 = _interopRequireDefault(_json);
	
	var _rdf = __webpack_require__(76);
	
	var _rdf2 = _interopRequireDefault(_rdf);
	
	var _io = __webpack_require__(80);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Linter = function () {
	  function Linter(config) {
	    _classCallCheck(this, Linter);
	
	    this.config = config;
	    this.packagePath = config._[0];
	    this.io;
	    this.chalk = new _chalk2.default.constructor({ enabled: !this.config.boring });
	    this.collector = new _collector2.default();
	    this.addonMetadata = null;
	  }
	
	  _createClass(Linter, [{
	    key: 'colorize',
	    value: function colorize(type) {
	      switch (type) {
	        case constants.VALIDATION_ERROR:
	          return this.chalk.red;
	        case constants.VALIDATION_WARNING:
	          return this.chalk.yellow;
	        case constants.VALIDATION_NOTICE:
	          return this.chalk.blue;
	        default:
	          throw new Error((0, _utils2.singleLineString)(_templateObject, constants.MESSAGE_TYPES.join(', ')));
	      }
	    }
	  }, {
	    key: 'handleError',
	    value: function handleError(err) {
	      var _console = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console;
	
	      if (err.message.includes('DuplicateZipEntry')) {
	        this.collector.addError(messages.DUPLICATE_XPI_ENTRY);
	        this.print(_console);
	      } else if (err.message.includes('end of central directory record signature not found')) {
	        this.collector.addError(messages.BAD_ZIPFILE);
	        this.print(_console);
	      } else {
	        if (this.config.stack === true) {
	          _console.error(err.stack);
	        } else {
	          _console.error(this.chalk.red(err.message || err));
	        }
	      }
	    }
	  }, {
	    key: 'print',
	    value: function print() {
	      var _console = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : console;
	
	      if (this.config.output === 'json') {
	        _console.log(this.toJSON(this.config.pretty));
	      } else {
	        _console.log(this.textOutput());
	      }
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$input = _ref.input,
	          input = _ref$input === undefined ? this.output : _ref$input,
	          _ref$pretty = _ref.pretty,
	          pretty = _ref$pretty === undefined ? this.config.pretty : _ref$pretty,
	          _ref$_JSON = _ref._JSON,
	          _JSON = _ref$_JSON === undefined ? JSON : _ref$_JSON;
	
	      var args = [input];
	      if (pretty === true) {
	        args.push(null);
	        args.push(4);
	      }
	      return _JSON.stringify.apply(null, args);
	    }
	  }, {
	    key: 'textOutput',
	    value: function textOutput() {
	      var _this = this;
	
	      var _terminalWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _cli.terminalWidth;
	
	      var maxColumns = _terminalWidth();
	      var out = [];
	
	      out.push((0, _utils2.gettext)('Validation Summary:'));
	      out.push('');
	      out.push((0, _columnify2.default)(this.output.summary, {
	        showHeaders: false,
	        minWidth: 15
	      }));
	      out.push('');
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        var _loop = function _loop() {
	          var type = _step.value;
	          messageType = type + 's';
	
	          if (_this.output[messageType].length) {
	            outputConfig = {
	              code: {
	                dataTransform: function dataTransform(value) {
	                  return _this.colorize(type)(value);
	                },
	                headingTransform: function headingTransform() {
	                  return (0, _utils2.gettext)('Code');
	                },
	                maxWidth: 35
	              },
	              message: {
	                headingTransform: function headingTransform() {
	                  return (0, _utils2.gettext)('Message');
	                },
	                maxWidth: (maxColumns - 35) * .25
	              },
	              description: {
	                headingTransform: function headingTransform() {
	                  return (0, _utils2.gettext)('Description');
	                },
	                maxWidth: (maxColumns - 35) * .5
	              },
	              file: {
	                headingTransform: function headingTransform() {
	                  return (0, _utils2.gettext)('File');
	                },
	                maxWidth: (maxColumns - 35) * .25
	              },
	              line: {
	                headingTransform: function headingTransform() {
	                  return (0, _utils2.gettext)('Line');
	                },
	                maxWidth: 6
	              },
	              column: {
	                headingTransform: function headingTransform() {
	                  return (0, _utils2.gettext)('Column');
	                },
	                maxWidth: 6
	              }
	            };
	            outputColumns = ['code', 'message', 'description', 'file', 'line', 'column'];
	
	            // If the terminal is this small we cave and don't size things
	            // contextually anymore.
	
	            if (maxColumns < 60) {
	              delete outputColumns[outputColumns.indexOf('column')];
	              delete outputConfig.column;
	              delete outputColumns[outputColumns.indexOf('description')];
	              delete outputConfig.description;
	              delete outputColumns[outputColumns.indexOf('line')];
	              delete outputConfig.line;
	
	              outputConfig.message.maxWidth = 15;
	              outputConfig.file.maxWidth = 15;
	            } else if (maxColumns < 78) {
	              delete outputColumns[outputColumns.indexOf('description')];
	              delete outputConfig.description;
	
	              outputConfig.message.maxWidth = (maxColumns - 47) * .5;
	              outputConfig.file.maxWidth = (maxColumns - 35) * .5;
	            }
	
	            out.push(messageType.toUpperCase() + ':');
	            out.push('');
	            out.push((0, _columnify2.default)(_this.output[messageType], {
	              maxWidth: 35,
	              columns: outputColumns,
	              columnSplitter: '   ',
	              config: outputConfig
	            }));
	          }
	        };
	
	        for (var _iterator = constants.MESSAGE_TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var messageType;
	          var outputConfig;
	          var outputColumns;
	
	          _loop();
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return out.join('\n');
	    }
	  }, {
	    key: 'getAddonMetadata',
	    value: function getAddonMetadata() {
	      var _this2 = this;
	
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref2$_log = _ref2._log,
	          _log = _ref2$_log === undefined ? _logger2.default : _ref2$_log,
	          _ref2$ManifestJSONPar = _ref2.ManifestJSONParser,
	          ManifestJSONParser = _ref2$ManifestJSONPar === undefined ? _manifestjson2.default : _ref2$ManifestJSONPar;
	
	      if (this.addonMetadata !== null) {
	        _log.debug('Metadata already set; returning cached metadata.');
	        return Promise.resolve(this.addonMetadata);
	      }
	
	      return this.io.getFiles().then(function (files) {
	        if (files.hasOwnProperty(_const.INSTALL_RDF) && files.hasOwnProperty(_const.MANIFEST_JSON)) {
	          _log.warn('Both ' + _const.INSTALL_RDF + ' and ' + _const.MANIFEST_JSON + ' found');
	          _this2.collector.addError(messages.MULITPLE_MANIFESTS);
	          return {};
	        } else if (files.hasOwnProperty(_const.INSTALL_RDF)) {
	          _log.info('Retrieving metadata from install.rdf');
	          return _this2.io.getFileAsString(_const.INSTALL_RDF).then(function (rdfString) {
	            // Gets an xml document object.
	            var rdfScanner = new _rdf2.default(rdfString, _const.INSTALL_RDF);
	            return rdfScanner.getContents();
	          }).then(function (xmlDoc) {
	            _log.info('Got xmlDoc, running InstallRdfParser.getMetadata()');
	            return new _installrdf2.default(xmlDoc, _this2.collector).getMetadata();
	          });
	        } else if (files.hasOwnProperty(_const.MANIFEST_JSON)) {
	          _log.info('Retrieving metadata from manifest.json');
	          return _this2.io.getFileAsString(_const.MANIFEST_JSON).then(function (json) {
	            var manifestParser = new ManifestJSONParser(json, _this2.collector, { selfHosted: _this2.config.selfHosted, io: _this2.io });
	            return manifestParser.getMetadata();
	          });
	        } else {
	          _log.warn((0, _utils2.singleLineString)(_templateObject2, _const.INSTALL_RDF, _const.MANIFEST_JSON));
	          _this2.collector.addNotice(messages.TYPE_NO_MANIFEST_JSON);
	          _this2.collector.addNotice(messages.TYPE_NO_INSTALL_RDF);
	          return {};
	        }
	      }).then(function (addonMetadata) {
	        _this2.addonMetadata = addonMetadata;
	
	        // The type must be explicitly defined. This behaviour differs the
	        // historical approach by the amo-validator.
	        // See mozilla/addons-linter#411.
	        // In due course metadata checking code may surpass this error
	        // being added here.
	        if (!_this2.addonMetadata.type) {
	          _log.error('Addon type lookup failed');
	          _this2.collector.addError(messages.TYPE_NOT_DETERMINED);
	        }
	
	        return _this2.addonMetadata;
	      });
	    }
	  }, {
	    key: 'checkFileExists',
	    value: function checkFileExists(filepath) {
	      var _lstatPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.lstatPromise;
	
	      var invalidMessage = new Error('Path "' + filepath + '" is not a file or directory or does not exist.');
	      return _lstatPromise(filepath).then(function (stats) {
	        if (stats.isFile() === true || stats.isDirectory() === true) {
	          return stats;
	        } else {
	          throw invalidMessage;
	        }
	      }).catch(function (err) {
	        if (err.code !== 'ENOENT') {
	          throw err;
	        } else {
	          throw invalidMessage;
	        }
	      });
	    }
	  }, {
	    key: 'scanFiles',
	    value: function scanFiles(files) {
	      var promises = [];
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var filename = _step2.value;
	
	          promises.push(this.scanFile(filename));
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      return Promise.all(promises);
	    }
	  }, {
	    key: 'getScanner',
	    value: function getScanner(filename) {
	      if (filename === _const.CHROME_MANIFEST) {
	        return _chromemanifest2.default;
	      }
	
	      if (filename.match(constants.HIDDEN_FILE_REGEX) || filename.match(constants.FLAGGED_FILE_REGEX) || filename.match(constants.FLAGGED_FILE_EXTENSION_REGEX) || filename.match(constants.ALREADY_SIGNED_REGEX)) {
	        return _filename2.default;
	      }
	
	      switch ((0, _path.extname)(filename)) {
	        case '.css':
	          return _css2.default;
	        case '.html':
	        case '.htm':
	          return _html2.default;
	        case '.js':
	          return _javascript2.default;
	        case '.json':
	          return _json2.default;
	        case '.rdf':
	          return _rdf2.default;
	        default:
	          return _binary2.default;
	      }
	    }
	  }, {
	    key: 'scanFile',
	    value: function scanFile(filename) {
	      var _this3 = this;
	
	      var ScannerClass = this.getScanner(filename);
	      return this.io.getFile(filename, ScannerClass.fileResultType).then(function (fileData) {
	        // First: check that this file is under our 2MB parsing limit. Otherwise
	        // it will be very slow and may crash the lint with an out-of-memory
	        // error.
	        var fileSize = typeof _this3.io.files[filename].size !== 'undefined' ? _this3.io.files[filename].size : _this3.io.files[filename].uncompressedSize;
	        var maxSize = 1024 * 1024 * constants.MAX_FILE_SIZE_TO_PARSE_MB;
	
	        if (ScannerClass !== _binary2.default && fileSize >= maxSize) {
	          var filesizeError = Object.assign({}, messages.FILE_TOO_LARGE, {
	            file: filename,
	            type: constants.VALIDATION_ERROR
	          });
	          return Promise.resolve([filesizeError]);
	        }
	
	        var scanner = new ScannerClass(fileData, filename, {
	          addonMetadata: _this3.addonMetadata,
	          // This is for the JSONScanner, which is a bit of an anomaly and
	          // accesses the collector directly.
	          // TODO: Bring this in line with other scanners, see:
	          // https://github.com/mozilla/addons-linter/issues/895
	          collector: _this3.collector
	        });
	
	        return scanner.scan();
	      })
	      // messages should be a list of raw message data objects.
	      .then(function (messages) {
	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;
	
	        try {
	          for (var _iterator3 = messages[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var message = _step3.value;
	
	            if (typeof message.type === 'undefined') {
	              throw new Error('message.type must be defined');
	            }
	            _this3.collector._addMessage(message.type, message);
	          }
	        } catch (err) {
	          _didIteratorError3 = true;
	          _iteratorError3 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	              _iterator3.return();
	            }
	          } finally {
	            if (_didIteratorError3) {
	              throw _iteratorError3;
	            }
	          }
	        }
	
	        return;
	      });
	    }
	  }, {
	    key: 'extractMetadata',
	    value: function extractMetadata() {
	      var _this4 = this;
	
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref3$_Crx = _ref3._Crx,
	          _Crx = _ref3$_Crx === undefined ? _io.Crx : _ref3$_Crx,
	          _ref3$_console = _ref3._console,
	          _console = _ref3$_console === undefined ? console : _ref3$_console,
	          _ref3$_Directory = _ref3._Directory,
	          _Directory = _ref3$_Directory === undefined ? _io.Directory : _ref3$_Directory,
	          _ref3$_Xpi = _ref3._Xpi,
	          _Xpi = _ref3$_Xpi === undefined ? _io.Xpi : _ref3$_Xpi;
	
	      return (0, _utils2.checkMinNodeVersion)().then(function () {
	        return _this4.checkFileExists(_this4.packagePath);
	      }).then(function (stats) {
	        if (stats.isFile() === true) {
	          if (_this4.packagePath.endsWith('.crx')) {
	            _logger2.default.info('Package is a file ending in .crx; parsing as a CRX');
	            return new _Crx(_this4.packagePath);
	          } else {
	            _logger2.default.info('Package is a file. Attempting to parse as an .xpi/.zip');
	            return new _Xpi(_this4.packagePath);
	          }
	        } else if (stats.isDirectory()) {
	          _logger2.default.info('Package path is a directory. Parsing as a directory');
	          return new _Directory(_this4.packagePath);
	        }
	      }).then(function (io) {
	        io.setScanFileCallback(_this4.config.shouldScanFile);
	        _this4.io = io;
	        return _this4.getAddonMetadata();
	      }).then(function (addonMetadata) {
	        return _this4.markSpecialFiles(addonMetadata);
	      }).then(function (addonMetadata) {
	        _logger2.default.info('Metadata option is set to %s', _this4.config.metadata);
	        if (_this4.config.metadata === true) {
	          var metadataObject = {
	            // Reflects if errors were encountered in extraction
	            // of metadata.
	            hasErrors: _this4.output.errors.length !== 0,
	            metadata: addonMetadata
	          };
	
	          // If errors exist the data is available via the
	          // errors list.
	          if (metadataObject.hasErrors) {
	            metadataObject.errors = _this4.output.errors;
	          }
	
	          _console.log(_this4.toJSON({ input: metadataObject }));
	        }
	
	        return addonMetadata;
	      });
	    }
	  }, {
	    key: 'scan',
	    value: function scan() {
	      var _this5 = this;
	
	      var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	      return this.extractMetadata(deps).then(function () {
	        return _this5.io.getFiles();
	      }).then(function (files) {
	        // Known libraries do not need to be scanned
	        var filesWithoutJSLibraries = Object.keys(files).filter(function (file) {
	          return !_this5.addonMetadata.jsLibs.hasOwnProperty(file);
	        }, _this5);
	        return _this5.scanFiles(filesWithoutJSLibraries);
	      }).then(function () {
	        _this5.print();
	        // This is skipped in the code coverage because the
	        // test runs against un-instrumented code.
	        /* istanbul ignore if  */
	        if (_this5.config.runAsBinary === true) {
	          var exitCode = _this5.output.errors.length > 0 ? 1 : 0;
	          if (exitCode === 0 && _this5.config.warningsAsErrors === true) {
	            exitCode = _this5.output.warnings.length > 0 ? 1 : 0;
	          }
	          process.exit(exitCode);
	        }
	      }).catch(function (err) {
	        _this5.handleError(err, deps._console);
	        throw err;
	      });
	    }
	  }, {
	    key: 'run',
	    value: function run() {
	      var _this6 = this;
	
	      var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	      if (this.config.metadata === true) {
	        return this.extractMetadata(deps).then(function () {
	          // This is skipped in the code coverage because the
	          // test runs against un-instrumented code.
	          /* istanbul ignore if  */
	          if (_this6.config.runAsBinary === true) {
	            process.exit(_this6.output.errors.length > 0 ? 1 : 0);
	          }
	        }).catch(function (err) {
	          _logger2.default.debug(err);
	          _this6.handleError(err, deps._console);
	          throw err;
	        });
	      } else {
	        return this.scan(deps);
	      }
	    }
	  }, {
	    key: 'markSpecialFiles',
	    value: function markSpecialFiles(addonMetadata) {
	      var _this7 = this;
	
	      return this._markEmptyFiles(addonMetadata).then(function (addonMetadata) {
	        return _this7._markJSLibs(addonMetadata);
	      }).then(function (addonMetadata) {
	        return _this7._markBannedLibs(addonMetadata);
	      });
	    }
	  }, {
	    key: '_markBannedLibs',
	    value: function _markBannedLibs(addonMetadata) {
	      var _unadvisedLibraries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _libraries.UNADVISED_LIBRARIES;
	
	      for (var pathToFile in addonMetadata.jsLibs) {
	        if (_libraries.BANNED_LIBRARIES.includes(addonMetadata.jsLibs[pathToFile])) {
	          this.collector.addError(Object.assign({}, messages.BANNED_LIBRARY, {
	            file: pathToFile
	          }));
	        }
	
	        if (_unadvisedLibraries.includes(addonMetadata.jsLibs[pathToFile])) {
	          this.collector.addWarning(Object.assign({}, messages.UNADVISED_LIBRARY, {
	            file: pathToFile
	          }));
	        }
	      }
	
	      return addonMetadata;
	    }
	  }, {
	    key: '_markEmptyFiles',
	    value: function _markEmptyFiles(addonMetadata) {
	      var emptyFiles = [];
	
	      return this.io.getFiles().then(function (files) {
	        for (var filename in files) {
	          if (typeof files[filename].size === 'undefined' && typeof files[filename].uncompressedSize === 'undefined') {
	            throw new Error('No size available for ' + filename);
	          }
	
	          if (files[filename].size === 0 || files[filename].uncompressedSize === 0) {
	            emptyFiles.push(filename);
	          }
	        }
	
	        addonMetadata.emptyFiles = emptyFiles;
	        return addonMetadata;
	      });
	    }
	  }, {
	    key: '_markJSLibs',
	    value: function _markJSLibs(addonMetadata) {
	      var _this8 = this;
	
	      var dispensary = new _dispensary2.default();
	      var jsLibs = {};
	      var promises = [];
	
	      return this.io.getFilesByExt('.js').then(function (files) {
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;
	
	        try {
	          var _loop2 = function _loop2() {
	            var filename = _step4.value;
	
	            promises.push(_this8.io.getFile(filename).then(function (file) {
	              var hashResult = dispensary.match(file);
	
	              if (hashResult !== false) {
	                _logger2.default.debug(hashResult + ' detected in ' + filename);
	                jsLibs[filename] = hashResult;
	
	                _this8.collector.addNotice(Object.assign({}, messages.KNOWN_LIBRARY, {
	                  file: filename
	                }));
	              }
	            }));
	          };
	
	          for (var _iterator4 = files[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            _loop2();
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }
	
	        return Promise.all(promises);
	      }).then(function () {
	        addonMetadata.jsLibs = jsLibs;
	        return addonMetadata;
	      });
	    }
	  }, {
	    key: 'output',
	    get: function get() {
	      var output = {
	        count: this.collector.length,
	        summary: {},
	        metadata: this.addonMetadata
	      };
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;
	
	      try {
	        for (var _iterator5 = constants.MESSAGE_TYPES[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var _type = _step5.value;
	
	          var messageType = _type + 's';
	          output[messageType] = this.collector[messageType];
	          output.summary[messageType] = this.collector[messageType].length;
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	
	      return output;
	    }
	  }]);
	
	  return Linter;
	}();
	
	exports.default = Linter;

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = require("columnify");

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = require("chalk");

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = require("dispensary");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.readdirPromise = exports.lstatPromise = undefined;
	exports.walkPromise = walkPromise;
	
	var _fs = __webpack_require__(17);
	
	var _path = __webpack_require__(12);
	
	var path = _interopRequireWildcard(_path);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _es6Promisify = __webpack_require__(18);
	
	var _es6Promisify2 = _interopRequireDefault(_es6Promisify);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var lstatPromise = exports.lstatPromise = (0, _es6Promisify2.default)(_fs.lstat);
	var readdirPromise = exports.readdirPromise = (0, _es6Promisify2.default)(_fs.readdir);
	
	function walkPromise(curPath) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$shouldIncludePat = _ref.shouldIncludePath,
	      shouldIncludePath = _ref$shouldIncludePat === undefined ? function () {
	    return true;
	  } : _ref$shouldIncludePat;
	
	  var result = {};
	  // Set a basePath var with the initial path
	  // so all file paths (the result keys) can
	  // be relative to the starting point.
	  var basePath = curPath;
	
	  return function walk(curPath) {
	    return lstatPromise(curPath).then(function (stat) {
	      var relPath = path.relative(basePath, curPath);
	      if (!shouldIncludePath(relPath)) {
	        _logger2.default.debug('Skipping file path: ' + relPath);
	        return result;
	      } else if (stat.isFile()) {
	        var size = stat.size;
	
	        result[relPath] = { size: size };
	      } else if (stat.isDirectory()) {
	        return readdirPromise(curPath).then(function (files) {
	          // Map the list of files and make a list of readdir
	          // promises to pass to Promise.all so we can recursively
	          // get the data on all the files in the directory.
	          return Promise.all(files.map(function (fileName) {
	            return walk(path.join(curPath, fileName));
	          }));
	        }).then(function () {
	          return result;
	        });
	      }
	    });
	  }(curPath);
	}

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = require("es6-promisify");

/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var BANNED_LIBRARIES = exports.BANNED_LIBRARIES = ['angularjs.1.0.1.angular.js', 'angularjs.1.0.1.angular.min.js', 'angularjs.1.0.2.angular.js', 'angularjs.1.0.2.angular.min.js', 'angularjs.1.0.3.angular.js', 'angularjs.1.0.3.angular.min.js', 'angularjs.1.0.4.angular.js', 'angularjs.1.0.4.angular.min.js', 'angularjs.1.0.5.angular.js', 'angularjs.1.0.5.angular.min.js', 'angularjs.1.0.6.angular.js', 'angularjs.1.0.6.angular.min.js', 'angularjs.1.0.7.angular.js', 'angularjs.1.0.7.angular.min.js', 'angularjs.1.0.8.angular.js', 'angularjs.1.0.8.angular.min.js', 'angularjs.1.1.1.angular.js', 'angularjs.1.1.1.angular.min.js', 'angularjs.1.1.3.angular.js', 'angularjs.1.1.3.angular.min.js', 'angularjs.1.1.4.angular.js', 'angularjs.1.1.4.angular.min.js', 'angularjs.1.1.5.angular.js', 'angularjs.1.1.5.angular.min.js', 'angularjs.1.2.0.angular.js', 'angularjs.1.2.0.angular.min.js', 'angularjs.1.2.1.angular.js', 'angularjs.1.2.1.angular.min.js', 'angularjs.1.2.2.angular.min.js', 'angularjs.1.2.10.angular.js', 'angularjs.1.2.10.angular.min.js', 'angularjs.1.2.11.angular.js', 'angularjs.1.2.11.angular.min.js', 'angularjs.1.2.12.angular.js', 'angularjs.1.2.12.angular.min.js', 'angularjs.1.2.13.angular.js', 'angularjs.1.2.13.angular.min.js', 'angularjs.1.2.14.angular.js', 'angularjs.1.2.14.angular.min.js', 'angularjs.1.2.15.angular.js', 'angularjs.1.2.15.angular.min.js', 'angularjs.1.2.16.angular.js', 'angularjs.1.2.16.angular.min.js', 'angularjs.1.2.17.angular.js', 'angularjs.1.2.17.angular.min.js', 'angularjs.1.2.18.angular.js', 'angularjs.1.2.18.angular.min.js', 'angularjs.1.2.19.angular.js', 'angularjs.1.2.19.angular.min.js', 'angularjs.1.2.20.angular.js', 'angularjs.1.2.20.angular.min.js', 'angularjs.1.2.21.angular.js', 'angularjs.1.2.21.angular.min.js', 'angularjs.1.2.22.angular.js', 'angularjs.1.2.22.angular.min.js', 'angularjs.1.2.23.angular.js', 'angularjs.1.2.23.angular.min.js', 'angularjs.1.2.24.angular.js', 'angularjs.1.2.24.angular.min.js', 'angularjs.1.2.25.angular.js', 'angularjs.1.2.25.angular.min.js', 'angularjs.1.2.26.angular.js', 'angularjs.1.2.26.angular.min.js', 'angularjs.1.2.27.angular.js', 'angularjs.1.2.27.angular.min.js', 'angularjs.1.2.28.angular.js', 'angularjs.1.2.28.angular.min.js', 'angularjs.1.2.29.angular.js', 'angularjs.1.2.29.angular.min.js', 'angularjs.1.2.3.angular.js', 'angularjs.1.2.3.angular.min.js', 'angularjs.1.2.4.angular.js', 'angularjs.1.2.4.angular.min.js', 'angularjs.1.2.5.angular.js', 'angularjs.1.2.5.angular.min.js', 'angularjs.1.2.6.angular.js', 'angularjs.1.2.6.angular.min.js', 'angularjs.1.2.7.angular.js', 'angularjs.1.2.7.angular.min.js', 'angularjs.1.2.8.angular.js', 'angularjs.1.2.8.angular.min.js', 'angularjs.1.2.9.angular.js', 'angularjs.1.2.9.angular.min.js', 'angularjs.1.3.0.angular.js', 'angularjs.1.3.0.angular.min.js', 'angularjs.1.3.1.angular.js', 'angularjs.1.3.1.angular.min.js', 'angularjs.1.3.2.angular.js', 'angularjs.1.3.2.angular.min.js', 'angularjs.1.3.3.angular.js', 'angularjs.1.3.3.angular.min.js', 'angularjs.1.3.4.angular.js', 'angularjs.1.3.4.angular.min.js', 'angularjs.1.3.5.angular.js', 'angularjs.1.3.5.angular.min.js', 'angularjs.1.3.6.angular.js', 'angularjs.1.3.6.angular.min.js', 'angularjs.1.3.7.angular.js', 'angularjs.1.3.7.angular.min.js', 'angularjs.1.3.8.angular.js', 'angularjs.1.3.8.angular.min.js', 'angularjs.1.3.9.angular.js', 'angularjs.1.3.9.angular.min.js', 'angularjs.1.3.10.angular.js', 'angularjs.1.3.10.angular.min.js', 'angularjs.1.3.11.angular.js', 'angularjs.1.3.11.angular.min.js', 'angularjs.1.3.12.angular.js', 'angularjs.1.3.12.angular.min.js', 'angularjs.1.3.13.angular.js', 'angularjs.1.3.13.angular.min.js', 'angularjs.1.3.14.angular.js', 'angularjs.1.3.14.angular.min.js', 'angularjs.1.3.15.angular.js', 'angularjs.1.3.15.angular.min.js', 'angularjs.1.3.16.angular.js', 'angularjs.1.3.16.angular.min.js', 'angularjs.1.3.17.angular.js', 'angularjs.1.3.17.angular.min.js', 'angularjs.1.3.18.angular.js', 'angularjs.1.3.18.angular.min.js', 'angularjs.1.3.19.angular.js', 'angularjs.1.3.19.angular.min.js', 'angularjs.1.3.20.angular.js', 'angularjs.1.3.20.angular.min.js', 'angularjs.1.4.0.angular.js', 'angularjs.1.4.0.angular.min.js', 'angularjs.1.4.1.angular.js', 'angularjs.1.4.1.angular.min.js', 'angularjs.1.4.2.angular.js', 'angularjs.1.4.2.angular.min.js', 'angularjs.1.4.3.angular.js', 'angularjs.1.4.3.angular.min.js', 'angularjs.1.4.4.angular.js', 'angularjs.1.4.4.angular.min.js', 'angularjs.1.4.5.angular.js', 'angularjs.1.4.5.angular.min.js', 'angularjs.1.4.6.angular.js', 'angularjs.1.4.6.angular.min.js', 'angularjs.1.4.7.angular.js', 'angularjs.1.4.7.angular.min.js', 'angularjs.1.4.8.angular.js', 'angularjs.1.4.8.angular.min.js', 'angularjs.1.4.9.angular.js', 'angularjs.1.4.9.angular.min.js', 'angularjs.1.4.10.angular.js', 'angularjs.1.4.10.angular.min.js', 'angularjs.1.5.0.angular.js', 'angularjs.1.5.0.angular.min.js', 'angularjs.1.5.1.angular.js', 'angularjs.1.5.1.angular.min.js', 'angularjs.1.5.2.angular.js', 'angularjs.1.5.2.angular.min.js', 'angularjs.1.5.3.angular.js', 'angularjs.1.5.3.angular.min.js', 'angularjs.1.5.4.angular.js', 'angularjs.1.5.4.angular.min.js', 'angularjs.1.5.5.angular.js', 'angularjs.1.5.5.angular.min.js', 'angularjs.1.5.6.angular.js', 'angularjs.1.5.6.angular.min.js', 'angularjs.1.5.7.angular.js', 'angularjs.1.5.7.angular.min.js', 'angularjs.1.5.8.angular.js', 'angularjs.1.5.8.angular.min.js', 'jquery.1.0.1.jquery.js', 'jquery.1.0.2.jquery.js', 'jquery.1.0.3.jquery.js', 'jquery.1.0.4.jquery.js', 'jquery.1.1.1.jquery.js', 'jquery.1.1.2.jquery.js', 'jquery.1.1.jquery.js', 'jquery.1.4.1.jquery.js', 'jquery.1.4.1.jquery.min.js', 'jquery.1.4.2.jquery.js', 'jquery.1.4.2.jquery.min.js', 'jquery.1.4.4.jquery.js', 'jquery.1.4.4.jquery.min.js', 'jquery.1.4.jquery.js', 'jquery.1.4.jquery.min.js', 'jquery.1.5.1.jquery.js', 'jquery.1.5.1.jquery.min.js', 'jquery.1.5.2.jquery.js', 'jquery.1.5.2.jquery.min.js', 'jquery.1.5.jquery.js', 'jquery.1.5.jquery.min.js', 'jquery.1.6.1.jquery.js', 'jquery.1.6.1.jquery.min.js', 'jquery.1.6.2.jquery.js', 'jquery.1.6.2.jquery.min.js', 'jquery.1.6.3.jquery.js', 'jquery.1.6.3.jquery.min.js', 'jquery.1.6.4.jquery.js', 'jquery.1.6.4.jquery.min.js', 'jquery.1.6.jquery.js', 'jquery.1.6.jquery.min.js', 'jquery.1.7.jquery.js', 'jquery.1.7.jquery.min.js', 'jquery.1.7.1.jquery.js', 'jquery.1.7.1.jquery.min.js', 'jquery.1.7.2.jquery.js', 'jquery.1.7.2.jquery.min.js', 'jquery.1.8.0.jquery.js', 'jquery.1.8.0.jquery.min.js', 'jquery.1.8.1.jquery.js', 'jquery.1.8.1.jquery.min.js', 'jquery.1.8.2.jquery.js', 'jquery.1.8.2.jquery.min.js', 'jquery.1.8.3.jquery.js', 'jquery.1.8.3.jquery.min.js', 'jquery.1.9.0.jquery.js', 'jquery.1.9.0.jquery.min.js', 'jquery.1.9.1.jquery.js', 'jquery.1.9.1.jquery.min.js', 'jquery.1.10.0.jquery.js', 'jquery.1.10.0.jquery.min.js', 'jquery.1.10.1.jquery.js', 'jquery.1.10.1.jquery.min.js', 'jquery.1.10.2.jquery.js', 'jquery.1.10.2.jquery.min.js', 'jquery.1.11.0.jquery.js', 'jquery.1.11.0.jquery.min.js', 'jquery.1.11.1.jquery.js', 'jquery.1.11.1.jquery.min.js', 'jquery.1.11.2.jquery.js', 'jquery.1.11.2.jquery.min.js', 'jquery.1.11.3.jquery.js', 'jquery.1.11.3.jquery.min.js', 'jquery.1.12.0.jquery.js', 'jquery.1.12.0.jquery.min.js', 'jquery.1.12.1.jquery.js', 'jquery.1.12.1.jquery.min.js', 'jquery.1.12.2.jquery.js', 'jquery.1.12.2.jquery.min.js', 'jquery.1.12.3.jquery.js', 'jquery.1.12.3.jquery.min.js', 'jquery.1.12.4.jquery.js', 'jquery.1.12.4.jquery.min.js'];
	
	var UNADVISED_LIBRARIES = exports.UNADVISED_LIBRARIES = [];

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _chromemanifest = __webpack_require__(21);
	
	Object.keys(_chromemanifest).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _chromemanifest[key];
	    }
	  });
	});
	
	var _css = __webpack_require__(22);
	
	Object.keys(_css).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _css[key];
	    }
	  });
	});
	
	var _html = __webpack_require__(23);
	
	Object.keys(_html).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _html[key];
	    }
	  });
	});
	
	var _javascript = __webpack_require__(24);
	
	Object.keys(_javascript).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _javascript[key];
	    }
	  });
	});
	
	var _json = __webpack_require__(25);
	
	Object.keys(_json).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _json[key];
	    }
	  });
	});
	
	var _layout = __webpack_require__(26);
	
	Object.keys(_layout).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _layout[key];
	    }
	  });
	});
	
	var _manifestjson = __webpack_require__(27);
	
	Object.keys(_manifestjson).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _manifestjson[key];
	    }
	  });
	});
	
	var _rdf = __webpack_require__(28);
	
	Object.keys(_rdf).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _rdf[key];
	    }
	  });
	});

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DANGEROUS_CATEGORY = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['Add-ons defining global properties via\n    category entries require careful review by an administrative reviewer.'], ['Add-ons defining global properties via\n    category entries require careful review by an administrative reviewer.']),
	    _templateObject2 = _taggedTemplateLiteral(['Given the potential security risks of\n    exposing APIs to unprivileged code, extensions which use these APIs must\n    undergo manual code review for at least one submission. If you are not\n    using these APIs to interact with content code, please consider\n    alternatives, such as JavaScript modules (http://mzl.la/1HMH2m9),\n    CommonJS modules (http://mzl.la/1JBMjuU, http://mzl.la/1OBaE8u), the\n    observer service (http://mzl.la/1MLqWdJ), or window listeners which\n    install global properties on privileged windows'], ['Given the potential security risks of\n    exposing APIs to unprivileged code, extensions which use these APIs must\n    undergo manual code review for at least one submission. If you are not\n    using these APIs to interact with content code, please consider\n    alternatives, such as JavaScript modules (http://mzl.la/1HMH2m9),\n    CommonJS modules (http://mzl.la/1JBMjuU, http://mzl.la/1OBaE8u), the\n    observer service (http://mzl.la/1MLqWdJ), or window listeners which\n    install global properties on privileged windows']);
	
	var _utils = __webpack_require__(6);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var DANGEROUS_CATEGORY = exports.DANGEROUS_CATEGORY = {
	  code: 'DANGEROUS_CATEGORY',
	  legacyCode: ['testcases_chromemanifest', 'test_resourcemodules', 'resource_modules'],
	  message: 'Potentially dangerous category entry',
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject)),
	  // TODO: signing_help is not yet used.
	  signing_help: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject2))
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.INVALID_SELECTOR_NESTING = exports.CSS_SYNTAX_ERROR = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['An error was found in the CSS file being\n    processed as a result further processing of that file is not possible'], ['An error was found in the CSS file being\n    processed as a result further processing of that file is not possible']),
	    _templateObject2 = _taggedTemplateLiteral(['Selectors should not be nested'], ['Selectors should not be nested']);
	
	var _utils = __webpack_require__(6);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var CSS_SYNTAX_ERROR = exports.CSS_SYNTAX_ERROR = {
	  code: 'CSS_SYNTAX_ERROR',
	  // This will be overriden by the reason passed from the error.
	  legacyCode: null,
	  message: (0, _utils.gettext)('A CSS syntax error was encountered'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject))
	};
	
	var INVALID_SELECTOR_NESTING = exports.INVALID_SELECTOR_NESTING = {
	  code: 'INVALID_SELECTOR_NESTING',
	  legacyCode: null,
	  message: (0, _utils.gettext)('Invalid nesting of selectors found'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject2))
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PREFWINDOW_REQUIRES_ID = exports._tagRequiresAttribute = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['The <', '> tag requires the\n      ', ', but it\'s missing.'], ['The <', '> tag requires the\n      ', ', but it\'s missing.']);
	
	var _utils = __webpack_require__(6);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var _tagRequiresAttribute = exports._tagRequiresAttribute = function _tagRequiresAttribute(tagName, attribute) {
	  return {
	    code: (tagName + '_REQUIRES_' + attribute).toUpperCase(),
	    legacyCode: ['markup', 'starttag', tagName + '_' + attribute],
	    message: (0, _utils.gettext)('<' + tagName + '> missing "' + attribute + '"'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject, tagName, attribute))
	  };
	};
	
	var PREFWINDOW_REQUIRES_ID = exports.PREFWINDOW_REQUIRES_ID = _tagRequiresAttribute('prefwindow', 'id');

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IDENTITY_GETREDIRECTURL = exports.STORAGE_SYNC = exports.STORAGE_LOCAL = exports.TABS_SENDREQUEST = exports.TABS_ONSELECTIONCHANGED = exports.TABS_ONACTIVECHANGED = exports.TABS_GETSELECTED = exports.TABS_GETALLINWINDOW = exports.EXT_SENDREQUEST = exports.EXT_ONREQUESTEXTERNAL = exports.EXT_ONREQUEST = exports.APP_GETDETAILS = exports.KNOWN_LIBRARY = exports.UNADVISED_LIBRARY = exports.BANNED_LIBRARY = exports.LOW_LEVEL_MODULE = exports.TAB_URL_OVERRIDE = exports.NSI_SOUND_PLAY = exports.INIT_NULL_ARG = exports.NSI_DNS_SERVICE_RESOLVE = exports.NO_DOCUMENT_WRITE = exports.ONLY_PREFS_IN_DEFAULTS = exports.UNEXPECTED_GLOGAL_ARG = exports.DEPREC_SDK_MOD_WIDGET = exports.EVAL_STRING_ARG = exports.BANNED_PROCESSNEXTEVENT = exports.BANNED_NEWTHREAD = exports._BANNED_IDENTIFIERS_MAP = exports.OPENDIALOG_NONLIT_URI = exports.OPENDIALOG_REMOTE_URI = exports.SHALLOW_WRAPPER = exports.MOZINDEXEDDB_PROPERTY = exports.MOZINDEXEDDB = exports.EVENT_LISTENER_FOURTH = exports.JS_SYNTAX_ERROR = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['There is a JavaScript syntax error in your\n    code; validation cannot continue on this file.'], ['There is a JavaScript syntax error in your\n    code; validation cannot continue on this file.']),
	    _templateObject2 = _taggedTemplateLiteral(['When called with a truthy forth argument,\n    listeners can be triggered potentially unsafely by untrusted code. This\n    requires careful review.'], ['When called with a truthy forth argument,\n    listeners can be triggered potentially unsafely by untrusted code. This\n    requires careful review.']),
	    _templateObject3 = _taggedTemplateLiteral(['Extensions using shallow XPCOM wrappers\n    cannot be automatically signed.'], ['Extensions using shallow XPCOM wrappers\n    cannot be automatically signed.']),
	    _templateObject4 = _taggedTemplateLiteral(['Calling \'', '\' with variable\n      parameters can result in potential security vulnerabilities if the\n      variable contains a remote URI. Consider using \'window.open\' with\n      the \'chrome=no\' flag.'], ['Calling \'', '\' with variable\n      parameters can result in potential security vulnerabilities if the\n      variable contains a remote URI. Consider using \'window.open\' with\n      the \'chrome=no\' flag.']),
	    _templateObject5 = _taggedTemplateLiteral(['Calling \'', '\' with a non-local\n      URI will result in the dialog being opened with chrome privileges.'], ['Calling \'', '\' with a non-local\n      URI will result in the dialog being opened with chrome privileges.']),
	    _templateObject6 = _taggedTemplateLiteral(['Creating threads from JavaScript is a common cause\n    of crashes and is unsupported in recent versions of the platform'], ['Creating threads from JavaScript is a common cause\n    of crashes and is unsupported in recent versions of the platform']),
	    _templateObject7 = _taggedTemplateLiteral(['Spinning the event loop with processNextEvent is a\n    common cause of deadlocks, crashes, and other errors due to unintended\n    reentrancy. Please use asynchronous callbacks instead wherever possible'], ['Spinning the event loop with processNextEvent is a\n    common cause of deadlocks, crashes, and other errors due to unintended\n    reentrancy. Please use asynchronous callbacks instead wherever possible']),
	    _templateObject8 = _taggedTemplateLiteral(['setTimeout and setInterval functions should be\n    called only with function expressions as their first argument'], ['setTimeout and setInterval functions should be\n    called only with function expressions as their first argument']),
	    _templateObject9 = _taggedTemplateLiteral(['The \'widget\' module has been deprecated\n    due to a number of performance and usability issues, and has been\n    removed from the SDK as of Firefox 40. Please use the\n    \'sdk/ui/button/action\' or \'sdk/ui/button/toggle\' module instead.\n    See https://developer.mozilla.org/Add-ons/SDK/High-Level_APIs/ui\n    for more information.'], ['The \'widget\' module has been deprecated\n    due to a number of performance and usability issues, and has been\n    removed from the SDK as of Firefox 40. Please use the\n    \'sdk/ui/button/action\' or \'sdk/ui/button/toggle\' module instead.\n    See https://developer.mozilla.org/Add-ons/SDK/High-Level_APIs/ui\n    for more information.']),
	    _templateObject10 = _taggedTemplateLiteral(['Passing a global as an argument\n    is not recommended. Please make this a var instead.'], ['Passing a global as an argument\n    is not recommended. Please make this a var instead.']),
	    _templateObject11 = _taggedTemplateLiteral(['Preference files are only allowed to call the\n    pref() and user_pref() functions. Please move other code outside preference\n    defaults file.'], ['Preference files are only allowed to call the\n    pref() and user_pref() functions. Please move other code outside preference\n    defaults file.']),
	    _templateObject12 = _taggedTemplateLiteral(['document.write will fail in many\n    circumstances when used in extensions, and has potentially severe security\n    repercussions when used improperly. Therefore, it should not be used.'], ['document.write will fail in many\n    circumstances when used in extensions, and has potentially severe security\n    repercussions when used improperly. Therefore, it should not be used.']),
	    _templateObject13 = _taggedTemplateLiteral(['The \'nsIDNSService.resolve\' method performs a\n    synchronous DNS lookup, which will freeze the UI. This can result in severe\n    performance issues. \'nsIDNSService.asyncResolve()\' should be used\n    instead.'], ['The \'nsIDNSService.resolve\' method performs a\n    synchronous DNS lookup, which will freeze the UI. This can result in severe\n    performance issues. \'nsIDNSService.asyncResolve()\' should be used\n    instead.']),
	    _templateObject14 = _taggedTemplateLiteral(['Calling \'nsITransferable.init()\' with a null\n    first argument has the potential to leak data across private browsing mode\n    sessions. \'null\' is  appropriate only when reading data or writing data\n    which is not associated with a particular window.'], ['Calling \'nsITransferable.init()\' with a null\n    first argument has the potential to leak data across private browsing mode\n    sessions. \'null\' is  appropriate only when reading data or writing data\n    which is not associated with a particular window.']),
	    _templateObject15 = _taggedTemplateLiteral(['The \'nsISound.play\' function is synchronous,\n    and thus freezes the interface while the sound is playing. It should be\n    avoided in favor of the HTML5 audio APIs.'], ['The \'nsISound.play\' function is synchronous,\n    and thus freezes the interface while the sound is playing. It should be\n    avoided in favor of the HTML5 audio APIs.']),
	    _templateObject16 = _taggedTemplateLiteral(['Extensions must not alter user preferences such\n    as the new tab URL without explicit user consent.'], ['Extensions must not alter user preferences such\n    as the new tab URL without explicit user consent.']),
	    _templateObject17 = _taggedTemplateLiteral(['Extensions must not alter user preferences\n    such as the new tab URL without explicit user consent. Such changes must\n    also be reverted when the extension is disabled or uninstalled.'], ['Extensions must not alter user preferences\n    such as the new tab URL without explicit user consent. Such changes must\n    also be reverted when the extension is disabled or uninstalled.']),
	    _templateObject18 = _taggedTemplateLiteral(['Your add-on uses an interface which\n    bypasses the high-level protections of the add-on SDK. This interface\n    should be avoided, and its use may significantly complicate\n    your review process'], ['Your add-on uses an interface which\n    bypasses the high-level protections of the add-on SDK. This interface\n    should be avoided, and its use may significantly complicate\n    your review process']),
	    _templateObject19 = _taggedTemplateLiteral(['Your add-on uses a JavaScript library we\n    consider unsafe. Read more: https://bit.ly/1TRIyZY'], ['Your add-on uses a JavaScript library we\n    consider unsafe. Read more: https://bit.ly/1TRIyZY']),
	    _templateObject20 = _taggedTemplateLiteral(['Your add-on uses a JavaScript library we do\n    not recommend. Read more: https://bit.ly/1TRIyZY'], ['Your add-on uses a JavaScript library we do\n    not recommend. Read more: https://bit.ly/1TRIyZY']),
	    _templateObject21 = _taggedTemplateLiteral(['JavaScript libraries are discouraged for\n    simple add-ons, but are generally accepted.'], ['JavaScript libraries are discouraged for\n    simple add-ons, but are generally accepted.']),
	    _templateObject22 = _taggedTemplateLiteral(['This API has been deprecated by Chrome\n      and has not been implemented by Firefox.'], ['This API has been deprecated by Chrome\n      and has not been implemented by Firefox.']),
	    _templateObject23 = _taggedTemplateLiteral(['This API can cause issues when loaded\n      temporarily using about:debugging in Firefox unless you specify\n      applications > gecko > id in the manifest. Please see:\n      https://mzl.la/2hizK4a for more.'], ['This API can cause issues when loaded\n      temporarily using about:debugging in Firefox unless you specify\n      applications > gecko > id in the manifest. Please see:\n      https://mzl.la/2hizK4a for more.']);
	
	exports._nonLiteralUri = _nonLiteralUri;
	exports._methodPassedRemoteUri = _methodPassedRemoteUri;
	exports._bannedIdentifier = _bannedIdentifier;
	
	var _utils = __webpack_require__(6);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var JS_SYNTAX_ERROR = exports.JS_SYNTAX_ERROR = {
	  code: 'JS_SYNTAX_ERROR',
	  legacyCode: ['testcases_scripting', 'test_js_file', 'syntax_error'],
	  message: (0, _utils.gettext)('JavaScript syntax error'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject))
	};
	
	var EVENT_LISTENER_FOURTH = exports.EVENT_LISTENER_FOURTH = {
	  code: 'EVENT_LISTENER_FOURTH',
	  message: (0, _utils.gettext)('addEventListener` called with truthy fourth argument.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject2)),
	  legacyCode: ['js', 'instanceactions', 'addEventListener_fourth']
	};
	
	var MOZINDEXEDDB = exports.MOZINDEXEDDB = {
	  code: 'MOZINDEXEDDB',
	  // Original code appeared to have a non-unique err_id which is no
	  // use for comparsions. ('testcases_regex', 'generic', '_generated')
	  legacyCode: null,
	  message: (0, _utils.gettext)('mozIndexedDB has been removed; use indexedDB instead'),
	  description: (0, _utils.gettext)('mozIndexedDB has been removed; use indexedDB instead.')
	};
	
	var MOZINDEXEDDB_PROPERTY = exports.MOZINDEXEDDB_PROPERTY = {
	  code: 'MOZINDEXEDDB_PROPERTY',
	  // Original code appeared to have a non-unique err_id which is no
	  // use for comparsions. ('testcases_regex', 'generic', '_generated')
	  legacyCode: null,
	  message: (0, _utils.gettext)('mozIndexedDB used as an object key/property'),
	  description: (0, _utils.gettext)('mozIndexedDB has been removed; use indexedDB instead.')
	};
	
	var SHALLOW_WRAPPER = exports.SHALLOW_WRAPPER = {
	  code: 'SHALLOW_WRAPPER',
	  legacyCode: ['testcases_js_xpcom', 'xpcnativewrapper', 'shallow'],
	  message: (0, _utils.gettext)('Shallow XPCOM wrappers should not be used'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject3))
	};
	
	function _nonLiteralUri(method) {
	  return {
	    code: (method + '_NONLIT_URI').toUpperCase(),
	    legacyCode: ['js', 'instanceactions', method + '_nonliteral'],
	    message: (0, _utils.gettext)('\'' + method + '\' called with a non-literal uri'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject4, method))
	  };
	}
	
	function _methodPassedRemoteUri(method) {
	  return {
	    code: (method + '_REMOTE_URI').toUpperCase(),
	    legacyCode: ['js', 'instanceactions', method + '_remote_uri'],
	    message: (0, _utils.gettext)('\'' + method + '\' called with non-local URI'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject5, method))
	  };
	}
	
	var OPENDIALOG_REMOTE_URI = exports.OPENDIALOG_REMOTE_URI = _methodPassedRemoteUri('openDialog');
	var OPENDIALOG_NONLIT_URI = exports.OPENDIALOG_NONLIT_URI = _nonLiteralUri('openDialog');
	
	var _BANNED_IDENTIFIERS_MAP = exports._BANNED_IDENTIFIERS_MAP = {
	  newThread: (0, _utils.singleLineString)(_templateObject6),
	  processNextEvent: (0, _utils.singleLineString)(_templateObject7)
	};
	
	function _bannedIdentifier(name) {
	  return {
	    code: 'BANNED_' + name.toUpperCase(),
	    legacyCode: ['js', 'actions', 'banned_identifier'],
	    message: (0, _utils.gettext)('Banned or deprecated JavaScript Identifier'),
	    description: _BANNED_IDENTIFIERS_MAP[name]
	  };
	}
	
	var BANNED_NEWTHREAD = exports.BANNED_NEWTHREAD = _bannedIdentifier('newThread');
	var BANNED_PROCESSNEXTEVENT = exports.BANNED_PROCESSNEXTEVENT = _bannedIdentifier('processNextEvent');
	var EVAL_STRING_ARG = exports.EVAL_STRING_ARG = {
	  code: 'EVAL_STRING_ARG',
	  message: (0, _utils.gettext)('setTimeout or setInterval must have function as 1st arg'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject8)),
	  legacyCode: ['javascript', 'dangerous_global', 'eval']
	};
	
	var DEPREC_SDK_MOD_WIDGET = exports.DEPREC_SDK_MOD_WIDGET = {
	  code: 'DEPREC_SDK_MOD_WIDGET',
	  message: (0, _utils.gettext)('Use of deprecated SDK module'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject9)),
	  legacyCode: null
	};
	
	var UNEXPECTED_GLOGAL_ARG = exports.UNEXPECTED_GLOGAL_ARG = {
	  code: 'UNEXPECTED_GLOGAL_ARG',
	  message: (0, _utils.gettext)('Unexpected global passed as an argument'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject10)),
	  legacyCode: null
	};
	
	var ONLY_PREFS_IN_DEFAULTS = exports.ONLY_PREFS_IN_DEFAULTS = {
	  code: 'ONLY_PREFS_IN_DEFAULTS',
	  message: (0, _utils.gettext)('Complex code should not appear in preference defaults files'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject11)),
	  legacyCode: ['testcases_javascript_actions', '_call_expression', 'complex_prefs_defaults_code']
	};
	
	var NO_DOCUMENT_WRITE = exports.NO_DOCUMENT_WRITE = {
	  code: 'NO_DOCUMENT_WRITE',
	  message: (0, _utils.gettext)('Use of document.write strongly discouraged.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject12)),
	  legacyCode: ['js', 'document.write', 'evil']
	};
	
	var NSI_DNS_SERVICE_RESOLVE = exports.NSI_DNS_SERVICE_RESOLVE = {
	  code: 'NSI_DNS_SERVICE_RESOLVE',
	  message: (0, _utils.gettext)('nsIDNSService.resolve() should not be used.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject13)),
	  legacyCode: ['testcases_javascript_entity_values', 'nsIDNSServiceResolve', null]
	};
	
	var INIT_NULL_ARG = exports.INIT_NULL_ARG = {
	  code: 'INIT_NULL_ARG',
	  message: (0, _utils.gettext)('`init` should not be called with a null first argument'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject14)),
	  legacyCode: ['js_entity_values', 'nsITransferable', 'init']
	};
	
	var NSI_SOUND_PLAY = exports.NSI_SOUND_PLAY = {
	  code: 'NSI_SOUND_PLAY',
	  message: (0, _utils.gettext)('nsISound.play should not be used.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject15)),
	  legacyCode: ['testcases_javascript_entity_values', 'nsISound_play', null]
	};
	
	var TAB_URL_OVERRIDE = exports.TAB_URL_OVERRIDE = {
	  code: 'TAB_URL_OVERRIDE',
	  message: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject16)),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject17)),
	  legacyCode: ['js_entity_values', 'NewTabURL', 'override']
	};
	
	var LOW_LEVEL_MODULE = exports.LOW_LEVEL_MODULE = {
	  code: 'LOW_LEVEL_MODULE',
	  message: (0, _utils.gettext)('Usage of low-level or non-SDK interface'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject18)),
	  legacyCode: null
	};
	
	var BANNED_LIBRARY = exports.BANNED_LIBRARY = {
	  code: 'BANNED_LIBRARY',
	  message: (0, _utils.gettext)('Banned 3rd-party JS library'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject19)),
	  legacyCode: null
	};
	
	var UNADVISED_LIBRARY = exports.UNADVISED_LIBRARY = {
	  code: 'UNADVISED_LIBRARY',
	  message: (0, _utils.gettext)('Unadvised 3rd-party JS library'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject20)),
	  legacyCode: null
	};
	
	var KNOWN_LIBRARY = exports.KNOWN_LIBRARY = {
	  code: 'KNOWN_LIBRARY',
	  message: (0, _utils.gettext)('Known JS library detected'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject21)),
	  legacyCode: ['testcases_content', 'test_packed_packages', 'blacklisted_js_library']
	};
	
	function deprecatedAPI(api) {
	  return {
	    code: (0, _utils.apiToMessage)(api),
	    legacyCode: ['js', 'deprecated', api],
	    message: (0, _utils.gettext)('"' + api + '" is deprecated or unimplemented'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject22))
	  };
	}
	
	var APP_GETDETAILS = exports.APP_GETDETAILS = deprecatedAPI('app.getDetails');
	var EXT_ONREQUEST = exports.EXT_ONREQUEST = deprecatedAPI('extension.onRequest');
	var EXT_ONREQUESTEXTERNAL = exports.EXT_ONREQUESTEXTERNAL = deprecatedAPI('extension.onRequestExternal');
	var EXT_SENDREQUEST = exports.EXT_SENDREQUEST = deprecatedAPI('extension.sendRequest');
	var TABS_GETALLINWINDOW = exports.TABS_GETALLINWINDOW = deprecatedAPI('tabs.getAllInWindow');
	var TABS_GETSELECTED = exports.TABS_GETSELECTED = deprecatedAPI('tabs.getSelected');
	var TABS_ONACTIVECHANGED = exports.TABS_ONACTIVECHANGED = deprecatedAPI('tabs.onActiveChanged');
	var TABS_ONSELECTIONCHANGED = exports.TABS_ONSELECTIONCHANGED = deprecatedAPI('tabs.onSelectionChanged');
	var TABS_SENDREQUEST = exports.TABS_SENDREQUEST = deprecatedAPI('tabs.sendRequest');
	
	function temporaryAPI(api) {
	  return {
	    code: (0, _utils.apiToMessage)(api),
	    legacyCode: ['js', 'temporary', api],
	    message: (0, _utils.gettext)('"' + api + '" can cause issues when loaded temporarily'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject23))
	  };
	}
	
	var STORAGE_LOCAL = exports.STORAGE_LOCAL = temporaryAPI('storage.local');
	var STORAGE_SYNC = exports.STORAGE_SYNC = temporaryAPI('storage.sync');
	var IDENTITY_GETREDIRECTURL = exports.IDENTITY_GETREDIRECTURL = temporaryAPI('identity.getRedirectURL');

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.JSON_DUPLICATE_KEY = exports.JSON_BLOCK_COMMENTS = exports.JSON_INVALID = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['Only line comments (comments beginning with\n    "//") are allowed in JSON files. Please remove block comments (comments\n    beginning with "/*")'], ['Only line comments (comments beginning with\n    "//") are allowed in JSON files. Please remove block comments (comments\n    beginning with "/*")']),
	    _templateObject2 = _taggedTemplateLiteral(['Duplicate key found in JSON file.'], ['Duplicate key found in JSON file.']);
	
	var _utils = __webpack_require__(6);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var JSON_INVALID = exports.JSON_INVALID = {
	  code: 'JSON_INVALID',
	  legacyCode: null,
	  message: (0, _utils.gettext)('Your JSON is not valid.'),
	  description: (0, _utils.gettext)('Your JSON file could not be parsed.')
	};
	
	var JSON_BLOCK_COMMENTS = exports.JSON_BLOCK_COMMENTS = {
	  code: 'JSON_BLOCK_COMMENTS',
	  legacyCode: null,
	  message: (0, _utils.gettext)('Your JSON contains block comments.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject))
	};
	
	var JSON_DUPLICATE_KEY = exports.JSON_DUPLICATE_KEY = {
	  code: 'JSON_DUPLICATE_KEY',
	  legacyCode: null,
	  message: (0, _utils.gettext)('Duplicate keys are not allowed in JSON files.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject2))
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ALREADY_SIGNED = exports.FLAGGED_FILE_TYPE = exports.FLAGGED_FILE_EXTENSION = exports.FLAGGED_FILE = exports.HIDDEN_FILE = exports.FILE_TOO_LARGE = exports.TYPE_NOT_DETERMINED = exports.MULITPLE_MANIFESTS = exports.TYPE_NO_MANIFEST_JSON = exports.TYPE_NO_INSTALL_RDF = exports.BAD_ZIPFILE = exports.DUPLICATE_XPI_ENTRY = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['The package contains multiple entries\n    with the same name. This practice has been banned. Try unzipping\n    and re-zipping your add-on package and try again.'], ['The package contains multiple entries\n    with the same name. This practice has been banned. Try unzipping\n    and re-zipping your add-on package and try again.']),
	    _templateObject2 = _taggedTemplateLiteral(['The type should be determined by\n    install.rdf if present. As there\'s no install.rdf, type detection\n    will be attempted to be inferred by package layout.'], ['The type should be determined by\n    install.rdf if present. As there\'s no install.rdf, type detection\n    will be attempted to be inferred by package layout.']),
	    _templateObject3 = _taggedTemplateLiteral(['The type should be determined by\n    manifest.json if present. As there\'s no manifest.json, type detection\n    will be attempted to be inferred by package layout.'], ['The type should be determined by\n    manifest.json if present. As there\'s no manifest.json, type detection\n    will be attempted to be inferred by package layout.']),
	    _templateObject4 = _taggedTemplateLiteral(['The type should be determined by\n    manifest.json if present. Both install_rdf and manifest_json\n    are defined.'], ['The type should be determined by\n    manifest.json if present. Both install_rdf and manifest_json\n    are defined.']),
	    _templateObject5 = _taggedTemplateLiteral(['The type detection algorithm could not\n    determine the type of the add-on.'], ['The type detection algorithm could not\n    determine the type of the add-on.']),
	    _templateObject6 = _taggedTemplateLiteral(['This file is not binary and is too large to\n    parse. Files larger than ', 'MB will not be\n    parsed. If your JavaScript file has a large list, consider removing the\n    list and loading it as a separate JSON file instead.'], ['This file is not binary and is too large to\n    parse. Files larger than ', 'MB will not be\n    parsed. If your JavaScript file has a large list, consider removing the\n    list and loading it as a separate JSON file instead.']),
	    _templateObject7 = _taggedTemplateLiteral(['Hidden files complicate the\n    review process and can contain sensitive information about the system that\n    generated the add-on. Please modify the packaging process so that these\n    files aren\'t included.'], ['Hidden files complicate the\n    review process and can contain sensitive information about the system that\n    generated the add-on. Please modify the packaging process so that these\n    files aren\'t included.']),
	    _templateObject8 = _taggedTemplateLiteral(['Files were found that are either unnecessary\n    or have been included unintentionally. They should be removed.'], ['Files were found that are either unnecessary\n    or have been included unintentionally. They should be removed.']),
	    _templateObject9 = _taggedTemplateLiteral(['Files whose names end with flagged extensions\n    have been found in the add-on. The extension of these files are flagged\n    because they usually identify binary components. Please see\n    https://bit.ly/review-policy for more information on the binary content\n    review process.'], ['Files whose names end with flagged extensions\n    have been found in the add-on. The extension of these files are flagged\n    because they usually identify binary components. Please see\n    https://bit.ly/review-policy for more information on the binary content\n    review process.']),
	    _templateObject10 = _taggedTemplateLiteral(['Add-ons which are already signed will be\n    re-signed when published on AMO. This will replace any existing signatures\n    on the add-on.'], ['Add-ons which are already signed will be\n    re-signed when published on AMO. This will replace any existing signatures\n    on the add-on.']);
	
	var _const = __webpack_require__(9);
	
	var _utils = __webpack_require__(6);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var DUPLICATE_XPI_ENTRY = exports.DUPLICATE_XPI_ENTRY = {
	  code: 'DUPLICATE_XPI_ENTRY',
	  legacyCode: ['testcases_packagelayout', 'test_layout_all', 'duplicate_entries'],
	  message: (0, _utils.gettext)('Package contains duplicate entries'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject))
	};
	
	var BAD_ZIPFILE = exports.BAD_ZIPFILE = {
	  code: 'BAD_ZIPFILE',
	  legacyCode: null,
	  message: 'Corrupt ZIP file',
	  description: (0, _utils.gettext)('We were unable to decompress the zip file.')
	};
	
	var TYPE_NO_INSTALL_RDF = exports.TYPE_NO_INSTALL_RDF = {
	  code: 'TYPE_NO_INSTALL_RDF',
	  legacyCode: ['typedetection', 'detect_type', 'missing_install_rdf'],
	  message: (0, _utils.gettext)('install.rdf was not found'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject2))
	};
	
	var TYPE_NO_MANIFEST_JSON = exports.TYPE_NO_MANIFEST_JSON = {
	  code: 'TYPE_NO_MANIFEST_JSON',
	  legacyCode: ['typedetection', 'detect_type', 'missing_manifest_json'],
	  message: (0, _utils.gettext)('manifest.json was not found'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject3))
	};
	
	var MULITPLE_MANIFESTS = exports.MULITPLE_MANIFESTS = {
	  code: 'MULITPLE_MANIFESTS',
	  legacyCode: ['typedetection', 'detect_type', 'install_rdf_and_manifest_json'],
	  message: (0, _utils.gettext)('Both install_rdf and manifest.json found'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject4))
	};
	
	var TYPE_NOT_DETERMINED = exports.TYPE_NOT_DETERMINED = {
	  code: 'TYPE_NOT_DETERMINED',
	  legacyCode: ['main', 'test_package', 'undeterminable_type'],
	  message: (0, _utils.gettext)('Unable to determine add-on type'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject5))
	};
	
	var FILE_TOO_LARGE = exports.FILE_TOO_LARGE = {
	  code: 'FILE_TOO_LARGE',
	  legacyCode: null,
	  message: (0, _utils.gettext)('File is too large to parse.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject6, _const.MAX_FILE_SIZE_TO_PARSE_MB))
	};
	
	var HIDDEN_FILE = exports.HIDDEN_FILE = {
	  code: 'HIDDEN_FILE',
	  legacyCode: ['testcases_content', 'test_packed_packages', 'hidden_files'],
	  message: (0, _utils.gettext)('Hidden file flagged'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject7))
	};
	
	var FLAGGED_FILE = exports.FLAGGED_FILE = {
	  code: 'FLAGGED_FILE',
	  legacyCode: ['testcases_content', 'test_packaged_packages', 'flagged_files'],
	  message: (0, _utils.gettext)('Flagged filename found'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject8))
	};
	
	var FLAGGED_FILE_EXTENSION = exports.FLAGGED_FILE_EXTENSION = {
	  code: 'FLAGGED_FILE_EXTENSION',
	  legacyCode: ['testcases_content', 'test_blacklisted_files', 'disallowed_extension'],
	  message: (0, _utils.gettext)('Flagged file extensions found'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject8))
	};
	
	var FLAGGED_FILE_TYPE = exports.FLAGGED_FILE_TYPE = {
	  code: 'FLAGGED_FILE_TYPE',
	  legacyCode: ['testcases_packagelayout', 'test_blacklisted_files', 'disallowed_file_type'],
	  message: (0, _utils.gettext)('Flagged file type found'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject9))
	};
	
	var ALREADY_SIGNED = exports.ALREADY_SIGNED = {
	  code: 'ALREADY_SIGNED',
	  legacyCode: null,
	  message: (0, _utils.gettext)('Package already signed'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject10))
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NO_DEFAULT_LOCALE = exports.NO_MESSAGES_FILE = exports.PROP_VERSION_MISSING = exports.PROP_NAME_MISSING = exports.MANIFEST_UNUSED_UPDATE = exports.MANIFEST_UPDATE_URL = exports.PROP_VERSION_TOOLKIT_ONLY = exports.PROP_VERSION_INVALID = exports.PROP_NAME_INVALID = exports.MANIFEST_CSP = exports.MANIFEST_VERSION_INVALID = exports.MANIFEST_PERMISSIONS = exports.MANIFEST_BAD_PERMISSION = exports.MANIFEST_FIELD_INVALID = exports.MANIFEST_FIELD_REQUIRED = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['Permissions must be strings. If a permission\n    is an object, it\'s likely from a Chrome App Extension and will not work in\n    Firefox. See https://mzl.la/1R1n1t0 (MDN Docs) for more information.'], ['Permissions must be strings. If a permission\n    is an object, it\'s likely from a Chrome App Extension and will not work in\n    Firefox. See https://mzl.la/1R1n1t0 (MDN Docs) for more information.']),
	    _templateObject2 = _taggedTemplateLiteral(['"applications.gecko.update_url" is not allowed\n    for Mozilla-hosted add-ons.'], ['"applications.gecko.update_url" is not allowed\n    for Mozilla-hosted add-ons.']),
	    _templateObject3 = _taggedTemplateLiteral(['The "update_url" is not used by Firefox in\n    the root of a manifest; your add-on will be updated via the Add-ons\n    site and not your "update_url". See: https://mzl.la/25zqk4O'], ['The "update_url" is not used by Firefox in\n    the root of a manifest; your add-on will be updated via the Add-ons\n    site and not your "update_url". See: https://mzl.la/25zqk4O']),
	    _templateObject4 = _taggedTemplateLiteral(['The "default_locale" value is specified in\n    the manifest, but no matching "messages.json" in the "_locales" directory\n    exists. See: https://mzl.la/2hjcaEE'], ['The "default_locale" value is specified in\n    the manifest, but no matching "messages.json" in the "_locales" directory\n    exists. See: https://mzl.la/2hjcaEE']),
	    _templateObject5 = _taggedTemplateLiteral(['The "default_locale" value is not specifed in\n    the manifest, but a "_locales" directory exists.\n    See: https://mzl.la/2hjcaEE'], ['The "default_locale" value is not specifed in\n    the manifest, but a "_locales" directory exists.\n    See: https://mzl.la/2hjcaEE']);
	
	exports.manifestPropMissing = manifestPropMissing;
	
	var _utils = __webpack_require__(6);
	
	var _const = __webpack_require__(9);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var MANIFEST_FIELD_REQUIRED = exports.MANIFEST_FIELD_REQUIRED = {
	  code: 'MANIFEST_FIELD_REQUIRED',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The field is required.'),
	  description: (0, _utils.gettext)('See https://mzl.la/1ZOhoEN (MDN Docs) for more information.'),
	  file: _const.MANIFEST_JSON
	};
	
	var MANIFEST_FIELD_INVALID = exports.MANIFEST_FIELD_INVALID = {
	  code: 'MANIFEST_FIELD_INVALID',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The field is invalid.'),
	  description: (0, _utils.gettext)('See https://mzl.la/1ZOhoEN (MDN Docs) for more information.'),
	  file: _const.MANIFEST_JSON
	};
	
	var MANIFEST_BAD_PERMISSION = exports.MANIFEST_BAD_PERMISSION = {
	  code: 'MANIFEST_BAD_PERMISSION',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The permission type is unsupported.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject)),
	  file: _const.MANIFEST_JSON
	};
	
	var MANIFEST_PERMISSIONS = exports.MANIFEST_PERMISSIONS = {
	  code: 'MANIFEST_PERMISSIONS',
	  legacyCode: null,
	  message: (0, _utils.gettext)('Unknown permission.'),
	  description: (0, _utils.gettext)('See https://mzl.la/1R1n1t0 (MDN Docs) for more information.'),
	  file: _const.MANIFEST_JSON
	};
	
	var MANIFEST_VERSION_INVALID = exports.MANIFEST_VERSION_INVALID = {
	  code: 'MANIFEST_VERSION_INVALID',
	  legacyCode: null,
	  message: (0, _utils.gettext)('"manifest_version" in the manifest.json is not a valid value'),
	  description: (0, _utils.gettext)('See https://mzl.la/20PenXl (MDN Docs) for more information.'),
	  file: _const.MANIFEST_JSON
	};
	
	var MANIFEST_CSP = exports.MANIFEST_CSP = {
	  code: 'MANIFEST_CSP',
	  legacyCode: null,
	  message: (0, _utils.gettext)('"content_security_policy" is defined in the manifest.json'),
	  description: (0, _utils.gettext)('A custom content_security_policy needs additional review.'),
	  file: MANIFEST_CSP
	};
	
	var PROP_NAME_INVALID = exports.PROP_NAME_INVALID = {
	  code: 'PROP_NAME_INVALID',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The "name" property must be a string.'),
	  description: (0, _utils.gettext)('See http://mzl.la/1STmr48 (MDN Docs) for more information.'),
	  file: _const.MANIFEST_JSON
	};
	
	var PROP_VERSION_INVALID = exports.PROP_VERSION_INVALID = {
	  code: 'PROP_VERSION_INVALID',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The "version" property must be a string.'),
	  description: (0, _utils.gettext)('See http://mzl.la/1kXIADa (MDN Docs) for more information.'),
	  file: _const.MANIFEST_JSON
	};
	
	var PROP_VERSION_TOOLKIT_ONLY = exports.PROP_VERSION_TOOLKIT_ONLY = {
	  code: 'PROP_VERSION_TOOLKIT_ONLY',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The "version" property uses a Firefox-specific format.'),
	  description: (0, _utils.gettext)('See http://mzl.la/1kXIADa (MDN Docs) for more information.'),
	  file: _const.MANIFEST_JSON
	};
	
	var MANIFEST_UPDATE_URL = exports.MANIFEST_UPDATE_URL = {
	  code: 'MANIFEST_UPDATE_URL',
	  legacyCode: null,
	  message: (0, _utils.gettext)('"update_url" is not allowed.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject2)),
	  file: _const.MANIFEST_JSON
	};
	
	var MANIFEST_UNUSED_UPDATE = exports.MANIFEST_UNUSED_UPDATE = {
	  code: 'MANIFEST_UNUSED_UPDATE',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The "update_url" property is not used by Firefox.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject3)),
	  file: _const.MANIFEST_JSON
	};
	
	function manifestPropMissing(property) {
	  return {
	    code: 'PROP_' + property.toUpperCase() + '_MISSING',
	    legacyCode: null,
	    message: (0, _utils.gettext)('No "' + property + '" property found in manifest.json'),
	    description: (0, _utils.gettext)('"' + property + '" is required'),
	    file: _const.MANIFEST_JSON
	  };
	}
	
	var PROP_NAME_MISSING = exports.PROP_NAME_MISSING = manifestPropMissing('name');
	var PROP_VERSION_MISSING = exports.PROP_VERSION_MISSING = manifestPropMissing('version');
	
	var NO_MESSAGES_FILE = exports.NO_MESSAGES_FILE = {
	  code: 'NO_MESSAGES_FILE',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The "default_locale" is missing localizations.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject4)),
	  file: _const.MANIFEST_JSON
	};
	
	var NO_DEFAULT_LOCALE = exports.NO_DEFAULT_LOCALE = {
	  code: 'NO_DEFAULT_LOCALE',
	  legacyCode: null,
	  message: (0, _utils.gettext)('The "default_locale" is missing but "_locales" exist.'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject5)),
	  file: _const.MANIFEST_JSON
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RDF_ID_MISSING = exports.RDF_VERSION_MISSING = exports.RDF_NAME_MISSING = exports.RDF_TYPE_MISSING = exports.RDF_TYPE_INVALID = exports.TAG_OBSOLETE_SKIN = exports.TAG_OBSOLETE_REQUIRES = exports.TAG_OBSOLETE_FILE = exports.TAG_NOT_ALLOWED_UPDATEURL = exports.TAG_NOT_ALLOWED_UPDATEKEY = exports.TAG_NOT_ALLOWED_HIDDEN = exports.RDF_GUID_TOO_LONG = exports._tagObsolete = exports._tagNotAllowedIfTag = exports._tagNotAllowed = undefined;
	
	var _templateObject = _taggedTemplateLiteral(['Your RDF file contains the <', '> tag,\n      which is not allowed in an Add-on.'], ['Your RDF file contains the <', '> tag,\n      which is not allowed in an Add-on.']),
	    _templateObject2 = _taggedTemplateLiteral(['Your RDF file contains the <', '> tag,\n      which cannot be used with a <', '> tag.'], ['Your RDF file contains the <', '> tag,\n      which cannot be used with a <', '> tag.']),
	    _templateObject3 = _taggedTemplateLiteral(['Your RDF file contains the <', '> tag,\n      which is obsolete.'], ['Your RDF file contains the <', '> tag,\n      which is obsolete.']),
	    _templateObject4 = _taggedTemplateLiteral(['A GUID must be 255 characters or less.\n    Please use a shorter GUID.'], ['A GUID must be 255 characters or less.\n    Please use a shorter GUID.']),
	    _templateObject5 = _taggedTemplateLiteral(['The only valid values for <em:type>\n    are 2, 4, 8, and 32. Any other values are either invalid or\n    deprecated.'], ['The only valid values for <em:type>\n    are 2, 4, 8, and 32. Any other values are either invalid or\n    deprecated.']),
	    _templateObject6 = _taggedTemplateLiteral(['It isn\'t always required, but it is\n    the most reliable method for determining add-on type.'], ['It isn\'t always required, but it is\n    the most reliable method for determining add-on type.']);
	
	exports.rdfTopLevelTagMissing = rdfTopLevelTagMissing;
	
	var _utils = __webpack_require__(6);
	
	var _const = __webpack_require__(9);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	var _tagNotAllowed = exports._tagNotAllowed = function _tagNotAllowed(tagName) {
	  return {
	    code: 'TAG_NOT_ALLOWED_' + tagName.toUpperCase(),
	    // Non-unique err_id so setting to null
	    // ('testcases_installrdf', '_test_rdf', 'shouldnt_exist')
	    legacyCode: null,
	    message: (0, _utils.gettext)('<' + tagName + '> tag is not allowed'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject, tagName))
	  };
	};
	
	var _tagNotAllowedIfTag = exports._tagNotAllowedIfTag = function _tagNotAllowedIfTag(tagName, otherTag) {
	  return {
	    code: 'TAG_NOT_ALLOWED_' + tagName.toUpperCase(),
	    // Non-unique err_id so setting to null
	    // ('testcases_installrdf', '_test_rdf', 'shouldnt_exist')
	    legacyCode: null,
	    message: (0, _utils.gettext)('<' + tagName + '> cannot be used with <' + otherTag + '>'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject2, tagName, otherTag))
	  };
	};
	
	var _tagObsolete = exports._tagObsolete = function _tagObsolete(tagName) {
	  return {
	    code: 'TAG_OBSOLETE_' + tagName.toUpperCase(),
	    // Non-unique err_id so setting to null
	    // ('testcases_installrdf', '_test_rdf', 'shouldnt_exist')
	    legacyCode: null,
	    message: (0, _utils.gettext)('<' + tagName + '> tag is obsolete'),
	    description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject3, tagName))
	  };
	};
	
	var RDF_GUID_TOO_LONG = exports.RDF_GUID_TOO_LONG = {
	  code: 'RDF_GUID_TOO_LONG',
	  legacyCode: null,
	  message: (0, _utils.gettext)('GUID is too long (over 255 chars)'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject4)),
	  file: _const.INSTALL_RDF
	};
	
	var TAG_NOT_ALLOWED_HIDDEN = exports.TAG_NOT_ALLOWED_HIDDEN = _tagNotAllowed('hidden');
	var TAG_NOT_ALLOWED_UPDATEKEY = exports.TAG_NOT_ALLOWED_UPDATEKEY = _tagNotAllowedIfTag('updateKey', 'listed');
	var TAG_NOT_ALLOWED_UPDATEURL = exports.TAG_NOT_ALLOWED_UPDATEURL = _tagNotAllowedIfTag('updateURL', 'listed');
	var TAG_OBSOLETE_FILE = exports.TAG_OBSOLETE_FILE = _tagObsolete('file');
	var TAG_OBSOLETE_REQUIRES = exports.TAG_OBSOLETE_REQUIRES = _tagObsolete('requires');
	var TAG_OBSOLETE_SKIN = exports.TAG_OBSOLETE_SKIN = _tagObsolete('skin');
	
	var RDF_TYPE_INVALID = exports.RDF_TYPE_INVALID = {
	  code: 'RDF_TYPE_INVALID',
	  legacyCode: ['typedetection', 'detect_type', 'invalid_em_type'],
	  message: (0, _utils.gettext)('Invalid <em:type> value'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject5)),
	  file: _const.INSTALL_RDF
	};
	
	var RDF_TYPE_MISSING = exports.RDF_TYPE_MISSING = {
	  code: 'RDF_TYPE_MISSING',
	  legacyCode: ['typedetection', 'detect_type', 'no_em:type'],
	  message: (0, _utils.gettext)('No <em:type> element found in install.rdf'),
	  description: (0, _utils.gettext)((0, _utils.singleLineString)(_templateObject6)),
	  file: _const.INSTALL_RDF
	};
	
	function rdfTopLevelTagMissing(tagName) {
	  return {
	    code: 'RDF_' + tagName.toUpperCase() + '_MISSING',
	    legacyCode: null,
	    message: (0, _utils.gettext)('No <em:' + tagName + '> element at the top level of install.rdf'),
	    description: (0, _utils.gettext)('<em:' + tagName + '> at the top level is required'),
	    file: _const.INSTALL_RDF
	  };
	}
	
	var RDF_NAME_MISSING = exports.RDF_NAME_MISSING = rdfTopLevelTagMissing('name');
	var RDF_VERSION_MISSING = exports.RDF_VERSION_MISSING = rdfTopLevelTagMissing('version');
	var RDF_ID_MISSING = exports.RDF_ID_MISSING = rdfTopLevelTagMissing('id');

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _message = __webpack_require__(30);
	
	var _message2 = _interopRequireDefault(_message);
	
	var _const = __webpack_require__(9);
	
	var constants = _interopRequireWildcard(_const);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// "I have a display case ready and waiting for our newest acquisitions!"
	// --Taneleer Tivan
	
	
	var Collector = function () {
	  function Collector() {
	    _classCallCheck(this, Collector);
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = constants.MESSAGE_TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var type = _step.value;
	
	        this[type + 's'] = [];
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	
	  _createClass(Collector, [{
	    key: '_addMessage',
	    value: function _addMessage(type, opts) {
	      var _Message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _message2.default;
	
	      // Message will throw for incorrect types.
	      // we have a test to ensure that is the case.
	      var message = new _Message(type, opts);
	      var list = this[type + 's'];
	      if (typeof list === 'undefined') {
	        throw new Error('Message type "' + type + '" not currently collected');
	      }
	      list.push(message);
	    }
	  }, {
	    key: 'addError',
	    value: function addError(opts) {
	      this._addMessage(constants.VALIDATION_ERROR, opts);
	    }
	  }, {
	    key: 'addNotice',
	    value: function addNotice(opts) {
	      this._addMessage(constants.VALIDATION_NOTICE, opts);
	    }
	  }, {
	    key: 'addWarning',
	    value: function addWarning(opts) {
	      this._addMessage(constants.VALIDATION_WARNING, opts);
	    }
	  }, {
	    key: 'length',
	    get: function get() {
	      var len = 0;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = constants.MESSAGE_TYPES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var type = _step2.value;
	
	          len += this[type + 's'].length;
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      return len;
	    }
	  }]);
	
	  return Collector;
	}();
	
	exports.default = Collector;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.requiredProps = exports.props = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['Message data object is missing the\n        following props: ', ''], ['Message data object is missing the\n        following props: ', '']),
	    _templateObject2 = _taggedTemplateLiteral(['Message type "', '"\n        is not one of ', ''], ['Message type "', '"\n        is not one of ', '']);
	
	var _const = __webpack_require__(9);
	
	var _utils = __webpack_require__(6);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	// These are the props we expect to pull out of
	// the data object passed to the Message constructor.
	var props = exports.props = ['code', 'message', 'description', 'column', 'file', 'line'];
	
	var requiredProps = exports.requiredProps = ['code', 'message', 'description'];
	
	var Message = function () {
	  function Message(type) {
	    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	    _classCallCheck(this, Message);
	
	    this.type = type;
	
	    if (data.hasOwnProperty('filename')) {
	      throw new Error('The key for the file is "file" not "filename"');
	    }
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var prop = _step.value;
	
	        this[prop] = data[prop];
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    var missingProps = [];
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = requiredProps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var _prop = _step2.value;
	
	        if (typeof this[_prop] === 'undefined') {
	          missingProps.push(_prop);
	        }
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	
	    if (missingProps.length) {
	      throw new Error((0, _utils.singleLineString)(_templateObject, missingProps.join(', ')));
	    }
	  }
	
	  _createClass(Message, [{
	    key: 'type',
	    get: function get() {
	      return this._type;
	    },
	    set: function set(type) {
	      if (!_const.MESSAGE_TYPES.includes(type)) {
	        throw new Error((0, _utils.singleLineString)(_templateObject2, type, _const.MESSAGE_TYPES.join(', ')));
	      }
	      this._type = type;
	    }
	  }]);
	
	  return Message;
	}();
	
	exports.default = Message;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['RDF node should only have a\n        single descendant <Description>'], ['RDF node should only have a\n        single descendant <Description>']);
	
	var _const = __webpack_require__(9);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _utils = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var InstallRdfParser = function () {
	  function InstallRdfParser(xmlDoc, collector) {
	    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	        _ref$namespace = _ref.namespace,
	        namespace = _ref$namespace === undefined ? _const.RDF_DEFAULT_NAMESPACE : _ref$namespace;
	
	    _classCallCheck(this, InstallRdfParser);
	
	    this.xmlDoc = xmlDoc;
	    // Provides ability to directly add messages to
	    // the collector.
	    this.collector = collector;
	    this.namespace = namespace;
	  }
	
	  _createClass(InstallRdfParser, [{
	    key: 'getMetadata',
	    value: function getMetadata() {
	      return Promise.resolve({
	        guid: this._getGUID(),
	        name: this._getName(),
	        type: this._getAddonType(),
	        version: this._getVersion(),
	        restartless: this._getIsBootstrapped()
	      });
	    }
	
	    /*
	     * Convert a nodeList to an Array.
	     */
	
	  }, {
	    key: '_makeArray',
	    value: function _makeArray(nodeList) {
	      return Array.prototype.slice.call(nodeList);
	    }
	
	    /*
	     * Gets topLevel tags e.g. RDF -> Description -> tag
	     */
	
	  }, {
	    key: '_getTopLevelNodesByTag',
	    value: function _getTopLevelNodesByTag(tagName) {
	      var descriptionTag = this._getDescriptionNode();
	      return this._makeArray(descriptionTag.childNodes).filter(function (node) {
	        return node.nodeName === tagName;
	      });
	    }
	  }, {
	    key: '_getTopLevelNodeByTag',
	    value: function _getTopLevelNodeByTag(tag) {
	      var nodes = this._getTopLevelNodesByTag(tag);
	      // Throw an error if there's more than one node as these
	      // should be unique.
	      if (nodes.length > 1) {
	        throw new Error('Multiple <' + tag + '> elements found');
	      }
	      return nodes[0];
	    }
	  }, {
	    key: '_getRDFNode',
	    value: function _getRDFNode() {
	      var rdfNodes = this.xmlDoc.getElementsByTagName('RDF');
	      if (!rdfNodes.length) {
	        throw new Error('RDF Node is not defined');
	      }
	      if (rdfNodes.length > 1) {
	        throw new Error('Multiple RDF tags found');
	      }
	      return rdfNodes[0];
	    }
	  }, {
	    key: '_getDescriptionNode',
	    value: function _getDescriptionNode() {
	      var rdfNode = this._getRDFNode();
	      var descriptionNodes = Array.prototype.slice.call(rdfNode.childNodes).filter(function (node) {
	        return node.nodeName === 'Description';
	      });
	      if (descriptionNodes.length > 1) {
	        throw new Error((0, _utils.singleLineString)(_templateObject));
	      }
	      return descriptionNodes[0];
	    }
	  }, {
	    key: '_getNodeValue',
	    value: function _getNodeValue(node) {
	      if (node && node.firstChild && node.firstChild.nodeValue) {
	        return node.firstChild.nodeValue;
	      }
	      return null;
	    }
	  }, {
	    key: '_getAddonType',
	    value: function _getAddonType() {
	      var addonType = null;
	      var node = this._getTopLevelNodeByTag('em:type');
	
	      if (node && node.firstChild && node.firstChild.nodeValue) {
	        var typeValue = node.firstChild.nodeValue;
	        if (!_const.ADDON_TYPE_MAP.hasOwnProperty(typeValue)) {
	          _logger2.default.debug('Invalid type value "%s"', typeValue);
	          this.collector.addError(messages.RDF_TYPE_INVALID);
	        } else {
	          addonType = _const.ADDON_TYPE_MAP[typeValue];
	          _logger2.default.debug('Mapping original <em:type> value "%s" -> "%s"', typeValue, addonType);
	        }
	      } else {
	        _logger2.default.warn('<em:type> was not found in install.rdf');
	        this.collector.addNotice(messages.RDF_TYPE_MISSING);
	      }
	      return addonType;
	    }
	  }, {
	    key: '_getIsBootstrapped',
	    value: function _getIsBootstrapped() {
	      return this._getNodeValue(this._getTopLevelNodeByTag('em:bootstrap')) === 'true';
	    }
	  }, {
	    key: '_getGUID',
	    value: function _getGUID() {
	      // Install.rdf only.
	      var guid = this._getNodeValue(this._getTopLevelNodeByTag('em:id'));
	      if (!guid) {
	        this.collector.addError(messages.RDF_ID_MISSING);
	      }
	      if (guid && guid.length > 255) {
	        this.collector.addError(messages.RDF_GUID_TOO_LONG);
	      }
	      return guid;
	    }
	  }, {
	    key: '_getName',
	    value: function _getName() {
	      var name = this._getNodeValue(this._getTopLevelNodeByTag('em:name'));
	      if (name === null) {
	        this.collector.addError(messages.RDF_NAME_MISSING);
	      }
	      return name;
	    }
	  }, {
	    key: '_getVersion',
	    value: function _getVersion() {
	      var version = this._getNodeValue(this._getTopLevelNodeByTag('em:version'));
	      if (version === null) {
	        this.collector.addError(messages.RDF_VERSION_MISSING);
	      }
	      return version;
	    }
	  }]);
	
	  return InstallRdfParser;
	}();
	
	exports.default = InstallRdfParser;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['/', ': Unknown ', '\n          "', '" at ', '.'], ['/', ': Unknown ', '\n          "', '" at ', '.']);
	
	var _relaxedJson = __webpack_require__(33);
	
	var _relaxedJson2 = _interopRequireDefault(_relaxedJson);
	
	var _validator = __webpack_require__(34);
	
	var _validator2 = _interopRequireDefault(_validator);
	
	var _cli = __webpack_require__(2);
	
	var _const = __webpack_require__(9);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _json = __webpack_require__(39);
	
	var _json2 = _interopRequireDefault(_json);
	
	var _formats = __webpack_require__(36);
	
	var _utils = __webpack_require__(6);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ManifestJSONParser = function (_JSONParser) {
	  _inherits(ManifestJSONParser, _JSONParser);
	
	  function ManifestJSONParser(jsonString, collector) {
	    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	        _ref$filename = _ref.filename,
	        filename = _ref$filename === undefined ? _const.MANIFEST_JSON : _ref$filename,
	        _ref$RelaxedJSON = _ref.RelaxedJSON,
	        RelaxedJSON = _ref$RelaxedJSON === undefined ? _relaxedJson2.default : _ref$RelaxedJSON,
	        _ref$selfHosted = _ref.selfHosted,
	        selfHosted = _ref$selfHosted === undefined ? (0, _cli.getConfig)().argv.selfHosted : _ref$selfHosted,
	        _ref$io = _ref.io,
	        io = _ref$io === undefined ? null : _ref$io;
	
	    _classCallCheck(this, ManifestJSONParser);
	
	    var _this = _possibleConstructorReturn(this, (ManifestJSONParser.__proto__ || Object.getPrototypeOf(ManifestJSONParser)).call(this, jsonString, collector, { filename: filename }));
	
	    _this.parse(RelaxedJSON);
	
	    // Set up some defaults in case parsing fails.
	    if (typeof _this.parsedJSON === 'undefined' || _this.isValid === false) {
	      _this.parsedJSON = {
	        manifestVersion: null,
	        name: null,
	        type: _const.PACKAGE_EXTENSION,
	        version: null
	      };
	    } else {
	      // We've parsed the JSON; now we can validate the manifest.
	      _this.selfHosted = selfHosted;
	      _this.io = io;
	      _this._validate();
	    }
	    return _this;
	  }
	
	  _createClass(ManifestJSONParser, [{
	    key: 'errorLookup',
	    value: function errorLookup(error) {
	      // This is the default message.
	      var baseObject = messages.JSON_INVALID;
	
	      // This is the default from webextension-manifest-schema, but it's not a
	      // super helpful error. We'll tidy it up a bit:
	      if (error && error.message) {
	        var lowerCaseMessage = error.message.toLowerCase();
	        if (lowerCaseMessage === 'should not have additional properties') {
	          error.message = 'is not a valid key or has invalid extra properties';
	        }
	      }
	
	      var overrides = {
	        message: '"' + error.dataPath + '" ' + error.message
	      };
	
	      if (error.keyword === 'required') {
	        baseObject = messages.MANIFEST_FIELD_REQUIRED;
	      } else if (error.dataPath.startsWith('/permissions') && typeof error.data !== 'undefined' && typeof error.data !== 'string') {
	        // Check for non-strings in the manifest permissions; these indicate
	        // a Chrome app extension. This means an error.
	        baseObject = messages.MANIFEST_BAD_PERMISSION;
	        overrides = {};
	      } else if (error.keyword === 'type') {
	        baseObject = messages.MANIFEST_FIELD_INVALID;
	      }
	
	      // Arrays can be extremely verbose, this tries to make them a little
	      // more sane. Using a regex because there will likely be more as we
	      // expand the schema.
	      var match = error.dataPath.match(/^\/(permissions)\/([\d+])/);
	      if (match && baseObject.code !== messages.MANIFEST_BAD_PERMISSION.code) {
	        baseObject = messages['MANIFEST_' + match[1].toUpperCase()];
	        overrides.message = (0, _utils.singleLineString)(_templateObject, match[1], match[1], error.data, match[2]);
	      }
	
	      return Object.assign({}, baseObject, overrides);
	    }
	  }, {
	    key: '_validate',
	    value: function _validate() {
	      // Not all messages returned by the schema are fatal to Firefox, messages
	      // that are just warnings should be added to this array.
	      var warnings = [messages.MANIFEST_PERMISSIONS.code];
	
	      this.isValid = (0, _validator2.default)(this.parsedJSON);
	      if (!this.isValid) {
	        _logger2.default.debug('Schema Validation messages', _validator2.default.errors);
	        var errorsFound = [];
	
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = _validator2.default.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var error = _step.value;
	
	            // Ensure that we only add one error on a field. This runs the risk
	            // of hiding errors, but means that we can aim to get to a more
	            // helpful error in the case of some rather verbose schema errors.
	            if (errorsFound.indexOf(error.dataPath) > -1) {
	              continue;
	            }
	
	            var message = this.errorLookup(error);
	            errorsFound.push(error.dataPath);
	
	            if (warnings.includes(message.code)) {
	              this.collector.addWarning(message);
	            } else {
	              this.collector.addError(message);
	            }
	
	            // Add-ons with bad permissions will fail to install in Firefox, so
	            // we consider them invalid.
	            if (message.code === messages.MANIFEST_BAD_PERMISSION.code) {
	              this.isValid = false;
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	
	      if (this.parsedJSON.content_security_policy) {
	        this.collector.addWarning(messages.MANIFEST_CSP);
	      }
	
	      if (this.parsedJSON.update_url) {
	        this.collector.addNotice(messages.MANIFEST_UNUSED_UPDATE);
	      }
	
	      if (!this.selfHosted && this.parsedJSON.applications && this.parsedJSON.applications.gecko && this.parsedJSON.applications.gecko.update_url) {
	        this.collector.addError(messages.MANIFEST_UPDATE_URL);
	        this.isValid = false;
	      }
	
	      if ((0, _formats.isToolkitVersionString)(this.parsedJSON.version)) {
	        this.collector.addNotice(messages.PROP_VERSION_TOOLKIT_ONLY);
	      }
	
	      if (this.parsedJSON.default_locale) {
	        var msg = '_locales/' + this.parsedJSON.default_locale + '/messages.json';
	        if (!this.io.files[msg]) {
	          this.collector.addError(messages.NO_MESSAGES_FILE);
	          this.isValid = false;
	        }
	      }
	
	      if (!this.parsedJSON.default_locale && this.io) {
	        var match_re = /^_locales\/.*?\/messages.json$/;
	        for (var filePath in this.io.files) {
	          if (filePath.match(match_re)) {
	            this.collector.addError(messages.NO_DEFAULT_LOCALE);
	            this.isValid = false;
	            break;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'getAddonId',
	    value: function getAddonId() {
	      try {
	        var id = this.parsedJSON.applications.gecko.id;
	        return typeof id === 'undefined' ? null : id;
	      } catch (e) {
	        _logger2.default.error('Failed to get the id from the manifest.');
	        return null;
	      }
	    }
	  }, {
	    key: 'getMetadata',
	    value: function getMetadata() {
	      return {
	        id: this.getAddonId(),
	        manifestVersion: this.parsedJSON.manifest_version,
	        name: this.parsedJSON.name,
	        type: _const.PACKAGE_EXTENSION,
	        version: this.parsedJSON.version
	      };
	    }
	  }]);
	
	  return ManifestJSONParser;
	}(_json2.default);
	
	exports.default = ManifestJSONParser;

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = require("relaxed-json");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.schemaObject = undefined;
	
	var _ajv = __webpack_require__(35);
	
	var _ajv2 = _interopRequireDefault(_ajv);
	
	var _formats = __webpack_require__(36);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var schemaObject = exports.schemaObject = __webpack_require__(38);
	
	var validator = (0, _ajv2.default)({
	  allErrors: true,
	  errorDataPath: 'property',
	  jsonPointers: true,
	  verbose: true
	});
	validator.addFormat('versionString', _formats.isValidVersionString);
	validator.addFormat('relativeURL', _formats.isRelativeURL);
	
	exports.default = validator.compile(schemaObject);

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = require("ajv");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isToolkitVersionString = isToolkitVersionString;
	exports.isValidVersionString = isValidVersionString;
	exports.isRelativeURL = isRelativeURL;
	
	var _urlParse = __webpack_require__(37);
	
	var _urlParse2 = _interopRequireDefault(_urlParse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var VALIDNUMRX = /^[0-9]{1,5}$/;
	
	// Firefox's version format is laxer than Chrome's, it accepts:
	// https://developer.mozilla.org/en-US/docs/Toolkit_version_format
	// We choose a slightly restricted version of that format (but still more
	// permissive than Chrome) to allow Beta addons, per:
	// https://developer.mozilla.org/en-US/Add-ons/AMO/Policy/Maintenance
	var TOOLKIT_VERSION_REGEX = /^(\d+\.?){1,3}\.(\d+([A-z]+(\-?[\dA-z]+)?))$/;
	
	function isToolkitVersionString(version) {
	  return TOOLKIT_VERSION_REGEX.test(version) && isValidVersionString(version);
	}
	
	function isValidVersionString(version) {
	  // We should be starting with a string.
	  if (typeof version !== 'string') {
	    return false;
	  }
	  // If valid toolkit version string, return true early
	  if (TOOLKIT_VERSION_REGEX.test(version)) {
	    return true;
	  }
	  var parts = version.split('.');
	  if (parts.length > 4) {
	    return false;
	  }
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var part = _step.value;
	
	      // Leading or multiple zeros not allowed.
	      if (part.startsWith('0') && part.length > 1) {
	        return false;
	      }
	      // Disallow things like 123e5 which parseInt will convert.
	      if (!VALIDNUMRX.test(part)) {
	        return false;
	      }
	      part = parseInt(part, 10);
	      if (Number.isNaN(part) || part < 0 || part > 65535) {
	        return false;
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return true;
	}
	
	function isRelativeURL(url) {
	  var parsed = (0, _urlParse2.default)(url);
	
	  if (parsed.protocol !== '' || parsed.href.startsWith('//')) {
	    return false;
	  }
	
	  return true;
	}

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = require("url-parse");

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = {
		"$schema": "http://json-schema.org/draft-04/schema#",
		"id": "http://jsonschema.net",
		"type": "object",
		"properties": {
			"applications": {
				"type": "object",
				"properties": {
					"gecko": {
						"type": "object",
						"properties": {
							"id": {
								"description": "id is the extension ID. Optional. See https://developer.mozilla.org/Add-ons/Install_Manifests#id",
								"pattern": "^{[A-Fa-f0-9]{8}-([A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}}$|^[A-Za-z0-9-._]*\\@[A-Za-z0-9-._]+$",
								"type": "string"
							},
							"strict_min_version": {
								"default": "42a1",
								"description": "Minimum version of Gecko to support. Defaults to '42a1'. (Requires Gecko 45)",
								"type": "string",
								"pattern": "^[0-9]{1,3}(\\.[a-z0-9]+)+$"
							},
							"strict_max_version": {
								"default": "*",
								"description": "Maximum version of Gecko to support. Defaults to '*'. (Requires Gecko 45)",
								"type": "string",
								"pattern": "^[0-9]{1,3}(\\.[a-z0-9*]+)+$"
							},
							"update_url": {
								"description": "Link to an add-on update manifest. (Requires Gecko 45)",
								"type": "string",
								"pattern": "^https://.*$"
							}
						}
					}
				}
			},
			"name": {
				"description": "Name of the extension. This is used to identify the extension in the browser's user interface and on sites like addons.mozilla.org.",
				"type": "string",
				"minLength": 2,
				"maxLength": 45
			},
			"homepage_url": {
				"description": "The URL of the homepage for this add-on. The add-on management page will contain a link to this URL.",
				"type": "string",
				"oneOf": [
					{
						"type": "string",
						"format": "uri"
					},
					{
						"type": "string",
						"pattern": "^__MSG_.*?__$"
					}
				]
			},
			"icons": {
				"description": "Icons to be shown in buttons and the add-on management page.",
				"type": "object",
				"patternProperties": {
					"^[1-9]\\d*$": {
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"background": {
				"description": "This key specifies how background scripts will work.",
				"type": "object",
				"properties": {
					"scripts": {
						"type": "array",
						"items": {
							"format": "relativeURL"
						}
					},
					"page": {
						"type": "string",
						"format": "relativeURL"
					},
					"persistent": {
						"type": "boolean"
					}
				},
				"additionalProperties": false
			},
			"manifest_version": {
				"description": "This key specifies the version of manifest.json used by this extension. Currently, this must always be 2.",
				"minimum": 2,
				"maximum": 2,
				"type": "integer"
			},
			"version": {
				"$ref": "#/definitions/versionString"
			},
			"permissions": {
				"description": "Permissions allowed for the extension",
				"type": "array",
				"uniqueItems": true,
				"items": {
					"anyOf": [
						{
							"type": "string",
							"enum": [
								"activeTab",
								"alarms",
								"bookmarks",
								"clipboardWrite",
								"contextMenus",
								"cookies",
								"downloads",
								"downloads.open",
								"downloads.shelf",
								"history",
								"idle",
								"nativeMessaging",
								"notifications",
								"storage",
								"tabs",
								"webNavigation",
								"webRequest",
								"webRequestBlocking",
								"<all_urls>"
							]
						},
						{
							"type": "string",
							"pattern": "^(https?|file|ftp|app|\\*)://(\\*|\\*\\.[^*/]+|[^*/]+)/.*$"
						},
						{
							"type": "string",
							"pattern": "^file:///.*$"
						}
					]
				}
			},
			"web_accessible_resources": {
				"description": "Resources accessible to the extension",
				"type": "array",
				"items": {
					"type": "string"
				}
			},
			"incognito": {
				"description": "The behaviour in incognito or private browsing mode",
				"type": "string",
				"pattern": "^spanning$"
			},
			"author": {
				"description": "Legacy field from Chrome. Use \"developer\" instead.",
				"type": "string"
			}
		},
		"required": [
			"name",
			"manifest_version",
			"version"
		],
		"definitions": {
			"versionString": {
				"format": "versionString",
				"type": "string",
				"description": "Version string must be a string comprising one to four dot-separated integers (0-65535). E.g: 1.2.3."
			}
		}
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _esprima = __webpack_require__(40);
	
	var _esprima2 = _interopRequireDefault(_esprima);
	
	var _relaxedJson = __webpack_require__(33);
	
	var _relaxedJson2 = _interopRequireDefault(_relaxedJson);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var JSONParser = function () {
	  function JSONParser(jsonString, collector) {
	    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	        _ref$filename = _ref.filename,
	        filename = _ref$filename === undefined ? null : _ref$filename;
	
	    _classCallCheck(this, JSONParser);
	
	    // Add the JSON string to the object; we'll use this for testing.
	    this._jsonString = jsonString;
	
	    // Provides ability to directly add messages to
	    // the collector.
	    this.collector = collector;
	
	    // Set the filename for this file
	    this.filename = filename;
	
	    // This marks whether a JSON file is valid; in the case of the base JSON
	    // parser, that's just whether it can be parsed and has duplicate keys.
	    this.isValid = null;
	  }
	
	  _createClass(JSONParser, [{
	    key: 'parse',
	    value: function parse() {
	      var _this = this;
	
	      var RelaxedJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _relaxedJson2.default;
	
	      try {
	        this.parsedJSON = JSON.parse(this._jsonString);
	      } catch (originalError) {
	        // First we'll try to remove comments with esprima;
	        // WebExtension manifests can contain comments, so we'll strip
	        // them out and see if we can parse the JSON.
	        // If not it's just garbage JSON and we error.
	        //
	        // Originally from https://github.com/abarreir/crx2ff/blob/d2b882056f902d751ad05e329efda7eddcb9d268/libs/ext-converter.js#L19-L37
	        var manifestString = 'var o = ' + this._jsonString;
	        try {
	          // This converts the JSON into a real JS object, and removes any
	          // comments from the JS code.
	          // This has some drawbacks because JSON and JS are not _100%_
	          // compatible. This is largely to do with Unicode characters we
	          // wouldn't expect to see in manifests anyway, and it should simply be
	          // a JSON parse error anyway.
	          // See:
	          // http://stackoverflow.com/questions/23752156/are-all-json-objects-also-valid-javascript-objects/23753148#23753148
	          // https://github.com/judofyr/timeless/issues/57#issuecomment-31872462
	          var tokens = _esprima2.default.tokenize(manifestString, { comment: true }).slice(3);
	          this._jsonString = tokens.reduce(function (json, token) {
	            // Ignore line comments (`// comments`) and just return the existing
	            // json we've built.
	            if (token.type === 'LineComment') {
	              return json;
	            }
	
	            // Block comments are not allowed, so this is an error.
	            if (token.type === 'BlockComment') {
	              _this.collector.addError(messages.JSON_BLOCK_COMMENTS);
	              _this.isValid = false;
	            }
	
	            return '' + json + token.value;
	          }, '');
	
	          // We found block-level comments, so this manifest is not valid.
	          // Don't bother parsing it again.
	          if (this.isValid === false) {
	            return;
	          }
	
	          this.parsedJSON = JSON.parse(this._jsonString);
	        } catch (error) {
	          // There was still an error, so looks like this manifest is actually
	          // invalid.
	          var errorData = Object.assign({}, messages.JSON_INVALID, {
	            file: this.filename,
	            description: error.message
	          });
	          this.collector.addError(errorData);
	          this.isValid = false;
	          return;
	        }
	      }
	
	      // Check for duplicate keys, which renders the manifest invalid.
	      this._checkForDuplicateKeys(RelaxedJSON);
	
	      // If never marked as invalid, this is a valid JSON file.
	      if (this.isValid !== false) {
	        this.isValid = true;
	      }
	    }
	  }, {
	    key: '_checkForDuplicateKeys',
	    value: function _checkForDuplicateKeys() {
	      var RelaxedJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _relaxedJson2.default;
	
	      try {
	        RelaxedJSON.parse(this._jsonString, { duplicate: true, tolerant: true });
	      } catch (err) {
	        if (err.warnings && err.warnings.length > 0) {
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;
	
	          try {
	            for (var _iterator = err.warnings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var error = _step.value;
	
	              if (error.message.startsWith('Duplicate key:')) {
	                var message = Object.assign({}, messages.JSON_DUPLICATE_KEY, {
	                  file: this.filename,
	                  line: error.line,
	                  description: error.message + ' found in JSON'
	                });
	                this.collector.addError(message);
	                this.isValid = false;
	              }
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	        }
	      }
	    }
	  }]);
	
	  return JSONParser;
	}();
	
	exports.default = JSONParser;

/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = require("esprima");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _base = __webpack_require__(42);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _const = __webpack_require__(9);
	
	var constants = _interopRequireWildcard(_const);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BinaryScanner = function (_BaseScanner) {
	  _inherits(BinaryScanner, _BaseScanner);
	
	  function BinaryScanner() {
	    _classCallCheck(this, BinaryScanner);
	
	    return _possibleConstructorReturn(this, (BinaryScanner.__proto__ || Object.getPrototypeOf(BinaryScanner)).apply(this, arguments));
	  }
	
	  _createClass(BinaryScanner, [{
	    key: 'check',
	    value: function check(buffer, values) {
	      for (var v in values) {
	        if (values[v] !== buffer[v]) {
	          return;
	        }
	      }
	      this.linterMessages.push(Object.assign({}, messages.FLAGGED_FILE_TYPE, {
	        type: constants.VALIDATION_NOTICE,
	        file: this.filename
	      }));
	    }
	  }, {
	    key: 'scan',
	    value: function scan() {
	      var buffer = this.contents;
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = constants.FLAGGED_FILE_MAGIC_NUMBERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var entry = _step.value;
	
	          this.check(buffer, entry);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return Promise.resolve(this.linterMessages);
	    }
	  }], [{
	    key: 'fileStreamType',
	    get: function get() {
	      return 'chunk';
	    }
	  }]);
	
	  return BinaryScanner;
	}(_base2.default);
	
	exports.default = BinaryScanner;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(6);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var BaseScanner = function () {
	  _createClass(BaseScanner, null, [{
	    key: 'fileResultType',
	    get: function get() {
	      /*
	      Because each scanner expects a certain kind of data from the
	      io libraries, a string or stream for example, we'll let the
	      scanner define the type of data it expects. Most default to
	      string.
	       This can be overridden on the class.
	       Because contents is passed to the constructor, we need to be
	      able to access this before the constructor.
	      */
	      return 'string';
	    }
	  }]);
	
	  function BaseScanner(contents, filename) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	    _classCallCheck(this, BaseScanner);
	
	    this.contents = contents;
	    this.filename = filename;
	    this.options = options;
	    this.linterMessages = [];
	    this._defaultRules = [];
	    this._parsedContent = null;
	    this._rulesProcessed = 0;
	
	    (0, _utils.ensureFilenameExists)(this.filename);
	  }
	
	  _createClass(BaseScanner, [{
	    key: 'scan',
	    value: function scan() {
	      var _this = this;
	
	      var _rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._defaultRules;
	
	      return new Promise(function (resolve, reject) {
	        _this.getContents().then(function (contents) {
	          var promises = [];
	          // Ignore private functions exported in rule files.
	          //
	          // (These are exported for testing purposes, but we don't want
	          // to include them in our linter's rules.)
	          var rules = (0, _utils.ignorePrivateFunctions)(_rules);
	
	          for (var rule in rules) {
	            _this._rulesProcessed++;
	
	            promises.push(rules[rule](contents, _this.filename, _this.options));
	          }
	
	          return Promise.all(promises);
	        }).then(function (ruleResults) {
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;
	
	          try {
	            for (var _iterator = ruleResults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var messages = _step.value;
	
	              _this.linterMessages = _this.linterMessages.concat(messages);
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	
	          resolve(_this.linterMessages);
	        }).catch(reject);
	      });
	    }
	  }, {
	    key: 'getContents',
	    value: function getContents() {
	      var _this2 = this;
	
	      return new Promise(function (resolve, reject) {
	        if (_this2._parsedContent !== null) {
	          return resolve(_this2._parsedContent);
	        }
	
	        _this2._getContents().then(function (contents) {
	          _this2._parsedContent = contents;
	
	          resolve(_this2._parsedContent);
	        }).catch(reject);
	      });
	    }
	  }, {
	    key: '_getContents',
	    value: function _getContents() {
	      return Promise.reject(new Error('_getContents is not implemented'));
	    }
	  }]);
	
	  return BaseScanner;
	}();
	
	exports.default = BaseScanner;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _base = __webpack_require__(42);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _chromemanifest = __webpack_require__(44);
	
	var _chromemanifest2 = _interopRequireDefault(_chromemanifest);
	
	var _chromemanifest3 = __webpack_require__(46);
	
	var rules = _interopRequireWildcard(_chromemanifest3);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ChromeManifestScanner = function (_BaseScanner) {
	  _inherits(ChromeManifestScanner, _BaseScanner);
	
	  function ChromeManifestScanner() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, ChromeManifestScanner);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ChromeManifestScanner.__proto__ || Object.getPrototypeOf(ChromeManifestScanner)).call.apply(_ref, [this].concat(args))), _this), _this._defaultRules = rules, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(ChromeManifestScanner, [{
	    key: '_getContents',
	    value: function _getContents() {
	      var _ChromeManifestParser = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _chromemanifest2.default;
	
	      var cmParser = new _ChromeManifestParser(this.contents, this.filename);
	      return cmParser.parse();
	    }
	  }], [{
	    key: 'fileResultType',
	    get: function get() {
	      return 'stream';
	    }
	  }]);
	
	  return ChromeManifestScanner;
	}(_base2.default);
	
	exports.default = ChromeManifestScanner;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _readline = __webpack_require__(45);
	
	var _readline2 = _interopRequireDefault(_readline);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ChromeManifestParser = function () {
	  function ChromeManifestParser(stream, filename) {
	    _classCallCheck(this, ChromeManifestParser);
	
	    this.stream = stream;
	    this.filename = filename;
	    this.triples = null;
	  }
	
	  _createClass(ChromeManifestParser, [{
	    key: 'filterTriples',
	    value: function filterTriples() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          subject = _ref.subject,
	          predicate = _ref.predicate,
	          object = _ref.object;
	
	      return this.parse().then(function (triples) {
	        return new Promise(function (resolve) {
	          var filteredTriples = triples.filter(function (triple) {
	            var searches = { subject: subject, predicate: predicate, object: object };
	            for (var key in searches) {
	              var val = searches[key];
	              if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== undefined && val === triple[key]) {
	                return true;
	              }
	            }
	          });
	
	          resolve(filteredTriples);
	        });
	      });
	    }
	  }, {
	    key: 'parse',
	    value: function parse() {
	      var _this = this;
	
	      return new Promise(function (resolve) {
	        if (_this.triples !== null) {
	          resolve(_this.triples);
	        } else {
	          _this.triples = [];
	        }
	
	        var lineCount = 0;
	
	        var rl = _readline2.default.createInterface({
	          input: _this.stream
	        });
	
	        rl.on('line', function (line) {
	          lineCount += 1;
	
	          if (line.trim().startsWith('#', 0) === true) {
	            return;
	          }
	
	          var triple = line.split(/\s+/, 3);
	          if (triple.length === 2) {
	            triple.push('');
	          } else if (triple.length < 3) {
	            return;
	          }
	
	          _this.triples.push({
	            subject: triple[0],
	            predicate: triple[1],
	            object: triple[2],
	            line: lineCount,
	            filename: _this.filename
	          });
	        });
	
	        rl.on('close', function () {
	          resolve(_this.triples);
	        });
	      });
	    }
	  }]);
	
	  return ChromeManifestParser;
	}();
	
	exports.default = ChromeManifestParser;

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = require("readline");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _categories = __webpack_require__(47);
	
	Object.keys(_categories).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _categories[key];
	    }
	  });
	});

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DANGEROUS_CATEGORIES = undefined;
	exports.checkCategories = checkCategories;
	
	var _messages = __webpack_require__(20);
	
	var _const = __webpack_require__(9);
	
	var DANGEROUS_CATEGORIES = exports.DANGEROUS_CATEGORIES = ['JavaScript-global-constructor', 'JavaScript-global-constructor-prototype-alias', 'JavaScript-global-property', 'JavaScript-global-privileged-property', 'JavaScript-global-static-nameset', 'JavaScript-global-dynamic-nameset', 'JavaScript-DOM-class', 'JavaScript-DOM-interface'];
	
	function checkCategories(triples, filename) {
	  var validationMessages = [];
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = triples[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var triple = _step.value;
	
	      if (triple.subject === 'category' && (DANGEROUS_CATEGORIES.includes(triple.predicate) || triple.predicate === 'JavaScript' && triple.object.startsWith('global ') || triple.object.startsWith('DOM '))) {
	        var message = Object.assign({}, _messages.DANGEROUS_CATEGORY, {
	          file: filename,
	          line: triple.line,
	          type: _const.VALIDATION_WARNING
	        });
	        validationMessages.push(message);
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return validationMessages;
	}

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _css = __webpack_require__(49);
	
	var rules = _interopRequireWildcard(_css);
	
	var _postcss = __webpack_require__(51);
	
	var postcss = _interopRequireWildcard(_postcss);
	
	var _base = __webpack_require__(42);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _messages = __webpack_require__(20);
	
	var _const = __webpack_require__(9);
	
	var _utils = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CSSScanner = function (_BaseScanner) {
	  _inherits(CSSScanner, _BaseScanner);
	
	  function CSSScanner() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, CSSScanner);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = CSSScanner.__proto__ || Object.getPrototypeOf(CSSScanner)).call.apply(_ref, [this].concat(args))), _this), _this._defaultRules = rules, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(CSSScanner, [{
	    key: 'processCode',
	    value: function processCode(cssNode, cssInstruction) {
	      var _rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._defaultRules;
	
	      var file = this.filename;
	      var cssOptions = Object.assign({}, this.options, {
	        startLine: cssNode.source.start.line,
	        startColumn: cssNode.source.start.column
	      });
	
	      var info = {
	        file: file,
	        startLine: cssOptions.startLine,
	        startColumn: cssOptions.startColumn
	      };
	
	      if (cssNode.type === 'comment') {
	        _logger2.default.debug('Found CSS comment. Skipping', info);
	        return;
	      }
	
	      if (cssNode.type === 'atrule') {
	        _logger2.default.debug('Processing media rules');
	        if (cssNode.nodes && cssNode.nodes.length) {
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;
	
	          try {
	            for (var _iterator = cssNode.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var mediaCssNode = _step.value;
	
	              this.processCode(mediaCssNode, cssInstruction, _rules);
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	        } else {
	          _logger2.default.debug('No media rules found');
	        }
	        return;
	      }
	
	      _logger2.default.debug('Passing CSS code to rule function "%s"', cssInstruction, info);
	
	      this.linterMessages = this.linterMessages.concat(_rules[cssInstruction](cssNode, file, cssOptions));
	    }
	  }, {
	    key: 'scan',
	    value: function scan() {
	      var _this2 = this;
	
	      var _rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._defaultRules;
	
	      return new Promise(function (resolve, reject) {
	        _this2.getContents().then(function (ast) {
	          if (ast && ast.nodes) {
	            var rules = (0, _utils.ignorePrivateFunctions)(_rules);
	            var nodes = ast.nodes;
	
	            for (var cssInstruction in rules) {
	              _this2._rulesProcessed++;
	              var _iteratorNormalCompletion2 = true;
	              var _didIteratorError2 = false;
	              var _iteratorError2 = undefined;
	
	              try {
	                for (var _iterator2 = nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                  var cssNode = _step2.value;
	
	                  _this2.processCode(cssNode, cssInstruction, rules);
	                }
	              } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                    _iterator2.return();
	                  }
	                } finally {
	                  if (_didIteratorError2) {
	                    throw _iteratorError2;
	                  }
	                }
	              }
	            }
	          }
	
	          resolve(_this2.linterMessages);
	        }).catch(reject);
	      });
	    }
	  }, {
	    key: '_getContents',
	    value: function _getContents() {
	      var _this3 = this;
	
	      var _cssParser = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : postcss;
	
	      return new Promise(function (resolve, reject) {
	        try {
	          var rootNode = _cssParser.parse(_this3.contents, { from: _this3.filename });
	          return resolve(rootNode);
	        } catch (e) {
	          if (!e.reason || e.name !== 'CssSyntaxError') {
	            return reject(e);
	          } else {
	            _this3.linterMessages.push(Object.assign({}, _messages.CSS_SYNTAX_ERROR, {
	              type: _const.VALIDATION_WARNING,
	              // Use the reason for the error as the message.
	              // e.message includes an absolute path.
	              message: e.reason,
	              column: e.column,
	              line: e.line,
	              // We use our own ref to the file as postcss outputs
	              // absolute paths.
	              file: _this3.filename
	            }));
	          }
	
	          // A syntax error has been encounted so it's game over.
	          return resolve(null);
	        }
	      });
	    }
	  }]);
	
	  return CSSScanner;
	}(_base2.default);
	
	exports.default = CSSScanner;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _invalidNesting = __webpack_require__(50);
	
	Object.keys(_invalidNesting).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _invalidNesting[key];
	    }
	  });
	});

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.invalidNesting = invalidNesting;
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function invalidNesting(cssNode, filename) {
	  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	      startLine = _ref.startLine,
	      startColumn = _ref.startColumn;
	
	  var messageList = [];
	  if (cssNode.type === 'rule') {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = cssNode.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var node = _step.value;
	
	        if (node.type === 'rule') {
	          messageList.push(Object.assign({}, messages.INVALID_SELECTOR_NESTING, {
	            type: 'warning',
	            line: startLine,
	            column: startColumn,
	            file: filename
	          }));
	          break;
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	  return messageList;
	}

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = require("postcss");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _base = __webpack_require__(42);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	var _const = __webpack_require__(9);
	
	var constants = _interopRequireWildcard(_const);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var FilenameScanner = function (_BaseScanner) {
	  _inherits(FilenameScanner, _BaseScanner);
	
	  function FilenameScanner() {
	    _classCallCheck(this, FilenameScanner);
	
	    return _possibleConstructorReturn(this, (FilenameScanner.__proto__ || Object.getPrototypeOf(FilenameScanner)).apply(this, arguments));
	  }
	
	  _createClass(FilenameScanner, [{
	    key: 'scan',
	    value: function scan() {
	      var _this2 = this;
	
	      return new Promise(function (resolve) {
	        if (_this2.filename.match(constants.ALREADY_SIGNED_REGEX)) {
	          _this2.linterMessages.push(Object.assign({}, messages.ALREADY_SIGNED, {
	            type: constants.VALIDATION_WARNING,
	            file: _this2.filename
	          }));
	        } else if (_this2.filename.match(constants.HIDDEN_FILE_REGEX)) {
	          _this2.linterMessages.push(Object.assign({}, messages.HIDDEN_FILE, {
	            type: constants.VALIDATION_WARNING,
	            file: _this2.filename
	          }));
	        } else if (_this2.filename.match(constants.FLAGGED_FILE_REGEX)) {
	          _this2.linterMessages.push(Object.assign({}, messages.FLAGGED_FILE, {
	            type: constants.VALIDATION_WARNING,
	            file: _this2.filename
	          }));
	        } else if (_this2.filename.match(constants.FLAGGED_FILE_EXTENSION_REGEX)) {
	          _this2.linterMessages.push(Object.assign({}, messages.FLAGGED_FILE_EXTENSION, {
	            type: constants.VALIDATION_WARNING,
	            file: _this2.filename
	          }));
	        } else {
	          throw new Error('Filename didn\'t match a regex: ' + _this2.filename + '.');
	        }
	        return resolve(_this2.linterMessages);
	      });
	    }
	  }]);
	
	  return FilenameScanner;
	}(_base2.default);
	
	exports.default = FilenameScanner;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _cheerio = __webpack_require__(54);
	
	var _cheerio2 = _interopRequireDefault(_cheerio);
	
	var _base = __webpack_require__(42);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _html = __webpack_require__(55);
	
	var rules = _interopRequireWildcard(_html);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var HTMLScanner = function (_BaseScanner) {
	  _inherits(HTMLScanner, _BaseScanner);
	
	  function HTMLScanner() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, HTMLScanner);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = HTMLScanner.__proto__ || Object.getPrototypeOf(HTMLScanner)).call.apply(_ref, [this].concat(args))), _this), _this._defaultRules = rules, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  _createClass(HTMLScanner, [{
	    key: '_getContents',
	    value: function _getContents() {
	      var _this2 = this;
	
	      return new Promise(function (resolve) {
	        var htmlDoc = _cheerio2.default.load(_this2.contents);
	
	        resolve(htmlDoc);
	      });
	    }
	  }]);
	
	  return HTMLScanner;
	}(_base2.default);
	
	exports.default = HTMLScanner;

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = require("cheerio");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ensureRequiredAttributes = __webpack_require__(56);
	
	Object.keys(_ensureRequiredAttributes).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ensureRequiredAttributes[key];
	    }
	  });
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ensureRequiredAttributes = ensureRequiredAttributes;
	exports._ensureAttributesInTag = _ensureAttributesInTag;
	
	var _const = __webpack_require__(9);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function ensureRequiredAttributes($, filename) {
	  return new Promise(function (resolve) {
	    var linterMessages = [];
	
	    for (var tag in _const.HTML_TAGS_WITH_REQUIRED_ATTRIBUTES) {
	      linterMessages = linterMessages.concat(_ensureAttributesInTag($, tag, _const.HTML_TAGS_WITH_REQUIRED_ATTRIBUTES[tag], filename));
	    }
	
	    resolve(linterMessages);
	  });
	}
	
	function _ensureAttributesInTag($, tag, attributes, filename) {
	  var linterMessages = [];
	
	  $(tag).each(function (i, element) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var attributeName = _step.value;
	
	        var errorCode = (tag + '_REQUIRES_' + attributeName).toUpperCase();
	
	        if ($(element).attr(attributeName) === undefined) {
	          linterMessages.push({
	            code: errorCode,
	            message: messages[errorCode].message,
	            description: messages[errorCode].description,
	            sourceCode: '<' + tag + '>',
	            file: filename,
	            type: _const.VALIDATION_ERROR
	          });
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  });
	
	  return linterMessages;
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['JS rules must pass a valid message as\n                          the second argument to context.report()'], ['JS rules must pass a valid message as\n                          the second argument to context.report()']);
	
	var _eslint = __webpack_require__(58);
	
	var _eslint2 = _interopRequireDefault(_eslint);
	
	var _const = __webpack_require__(9);
	
	var _messages2 = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages2);
	
	var _javascript = __webpack_require__(59);
	
	var rules = _interopRequireWildcard(_javascript);
	
	var _utils = __webpack_require__(6);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var JavaScriptScanner = function () {
	  function JavaScriptScanner(code, filename) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	    _classCallCheck(this, JavaScriptScanner);
	
	    this._defaultRules = rules;
	
	    this.code = code;
	    this.filename = filename;
	    this.options = options;
	    this.linterMessages = [];
	    this._rulesProcessed = 0;
	
	    (0, _utils.ensureFilenameExists)(this.filename);
	  }
	
	  _createClass(JavaScriptScanner, [{
	    key: 'scan',
	    value: function scan() {
	      var _this = this;
	
	      var _ESLint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _eslint2.default;
	
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref$_rules = _ref._rules,
	          _rules = _ref$_rules === undefined ? this._defaultRules : _ref$_rules,
	          _ref$_ruleMapping = _ref._ruleMapping,
	          _ruleMapping = _ref$_ruleMapping === undefined ? _const.ESLINT_RULE_MAPPING : _ref$_ruleMapping,
	          _ref$_messages = _ref._messages,
	          _messages = _ref$_messages === undefined ? messages : _ref$_messages;
	
	      return new Promise(function (resolve) {
	        // ESLint is synchronous and doesn't accept streams, so we need to
	        // pass it the entire source file as a string.
	        var eslint = _ESLint.linter;
	        var rules = (0, _utils.ignorePrivateFunctions)(_rules);
	
	        for (var name in rules) {
	          _this._rulesProcessed++;
	          eslint.defineRule(name, rules[name]);
	        }
	
	        var report = eslint.verify(_this.code, {
	          env: { es6: true },
	          parserOptions: { ecmaVersion: 2017 },
	          ignore: false,
	          rules: _ruleMapping,
	          settings: {
	            addonMetadata: _this.options.addonMetadata
	          }
	        }, {
	          allowInlineConfig: false,
	          filename: _this.filename
	        });
	
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = report[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var message = _step.value;
	
	            // Fatal error messages (like SyntaxErrors) are a bit different, we
	            // need to handle them specially.
	            if (message.fatal === true) {
	              message.message = _messages.JS_SYNTAX_ERROR.code;
	            }
	
	            if (typeof message.message === 'undefined') {
	              throw new Error((0, _utils.singleLineString)(_templateObject));
	            }
	
	            // Fallback to looking up the message object by the
	            var messageObj = _messages[message.message];
	            var code = message.message;
	
	            _this.linterMessages.push({
	              code: code,
	              column: message.column,
	              description: messageObj.description,
	              file: _this.filename,
	              line: message.line,
	              message: messageObj.message,
	              sourceCode: message.source,
	              type: _const.ESLINT_TYPES[message.severity]
	            });
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        resolve(_this.linterMessages);
	      });
	    }
	  }], [{
	    key: 'fileResultType',
	    get: function get() {
	      return 'string';
	    }
	  }]);
	
	  return JavaScriptScanner;
	}();
	
	exports.default = JavaScriptScanner;

/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = require("eslint");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _banned_identifiers = __webpack_require__(60);
	
	Object.keys(_banned_identifiers).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _banned_identifiers[key];
	    }
	  });
	});
	
	var _deprecated_entities = __webpack_require__(61);
	
	Object.keys(_deprecated_entities).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _deprecated_entities[key];
	    }
	  });
	});
	
	var _eval_string_arg = __webpack_require__(62);
	
	Object.keys(_eval_string_arg).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _eval_string_arg[key];
	    }
	  });
	});
	
	var _event_listener_fourth = __webpack_require__(63);
	
	Object.keys(_event_listener_fourth).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _event_listener_fourth[key];
	    }
	  });
	});
	
	var _global_require_arg = __webpack_require__(64);
	
	Object.keys(_global_require_arg).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _global_require_arg[key];
	    }
	  });
	});
	
	var _init_null_arg = __webpack_require__(65);
	
	Object.keys(_init_null_arg).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _init_null_arg[key];
	    }
	  });
	});
	
	var _low_level_module = __webpack_require__(66);
	
	Object.keys(_low_level_module).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _low_level_module[key];
	    }
	  });
	});
	
	var _mozindexeddb = __webpack_require__(67);
	
	Object.keys(_mozindexeddb).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _mozindexeddb[key];
	    }
	  });
	});
	
	var _mozindexeddb_property = __webpack_require__(68);
	
	Object.keys(_mozindexeddb_property).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _mozindexeddb_property[key];
	    }
	  });
	});
	
	var _only_prefs_in_defaults = __webpack_require__(69);
	
	Object.keys(_only_prefs_in_defaults).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _only_prefs_in_defaults[key];
	    }
	  });
	});
	
	var _opendialog_nonlit_uri = __webpack_require__(70);
	
	Object.keys(_opendialog_nonlit_uri).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _opendialog_nonlit_uri[key];
	    }
	  });
	});
	
	var _opendialog_remote_uri = __webpack_require__(71);
	
	Object.keys(_opendialog_remote_uri).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _opendialog_remote_uri[key];
	    }
	  });
	});
	
	var _shallow_wrapper = __webpack_require__(72);
	
	Object.keys(_shallow_wrapper).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _shallow_wrapper[key];
	    }
	  });
	});
	
	var _webextension_api = __webpack_require__(73);
	
	Object.keys(_webextension_api).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _webextension_api[key];
	    }
	  });
	});
	
	var _widget_module = __webpack_require__(74);
	
	Object.keys(_widget_module).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _widget_module[key];
	    }
	  });
	});

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.banned_identifiers = banned_identifiers;
	
	var _const = __webpack_require__(9);
	
	function banned_identifiers(context) {
	  return {
	    Identifier: function Identifier(node) {
	      if (_const.BANNED_IDENTIFIERS.includes(node.name)) {
	        return context.report(node, 'BANNED_' + node.name.toUpperCase());
	      }
	    },
	    MemberExpression: function MemberExpression(node) {
	      if (_const.BANNED_IDENTIFIERS.includes(node.property.name)) {
	        return context.report(node, 'BANNED_' + node.property.name.toUpperCase());
	      }
	    }
	  };
	}

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DEPRECATED_ENTITIES = undefined;
	exports.deprecated_entities = deprecated_entities;
	
	var _messages = __webpack_require__(20);
	
	var _utils = __webpack_require__(6);
	
	var DEPRECATED_ENTITIES = exports.DEPRECATED_ENTITIES = [{
	  error: _messages.NO_DOCUMENT_WRITE,
	  object: 'document',
	  property: 'write'
	}, {
	  error: _messages.NSI_DNS_SERVICE_RESOLVE,
	  object: 'nsIDNSService',
	  property: 'resolve'
	}, {
	  error: _messages.NSI_SOUND_PLAY,
	  object: 'nsISound',
	  property: 'play'
	}, {
	  error: _messages.TAB_URL_OVERRIDE,
	  object: 'NewTabURL',
	  property: 'override'
	}];
	
	function deprecated_entities(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      var referenceNode = (0, _utils.getNodeReference)(context, node.callee);
	      // We're only looking for calls that look like `foo.bar()`.
	      if (typeof referenceNode.object !== 'undefined' && referenceNode.property.type === 'Identifier' && referenceNode.object.type === 'Identifier') {
	
	        var referenceObject = (0, _utils.getNodeReference)(context, referenceNode.object);
	
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = DEPRECATED_ENTITIES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var entity = _step.value;
	
	            // Check to see if the node matches a deprecated entity.
	            if (referenceObject.name === entity.object && referenceNode.property.name === entity.property) {
	              return context.report(node, entity.error.code);
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	    }
	  };
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.eval_string_arg = eval_string_arg;
	
	var _javascript = __webpack_require__(24);
	
	var _utils = __webpack_require__(6);
	
	function eval_string_arg(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      // Check if what's being called is setTimeout or setInterval
	      if (typeof node.callee.property !== 'undefined' && node.callee.property.type === 'Identifier' && (node.callee.property.name === 'setTimeout' || node.callee.property.name === 'setInterval')) {
	
	        // If the first arg is a variable check if it's a function
	        if (node.arguments.length > 0 && node.arguments[0].type === 'Identifier') {
	          var originalDef = (0, _utils.getVariable)(context, node.arguments[0].name);
	          if (originalDef && originalDef.type && originalDef.type !== 'FunctionExpression' && originalDef.type !== 'ArrowFunctionExpression') {
	            return context.report({ node: node, message: _javascript.EVAL_STRING_ARG.code });
	          } else {
	            return;
	          }
	          // Otherwise just check the type of the variable
	        } else if (node.arguments.length > 0 && node.arguments[0].type !== 'FunctionExpression' && node.arguments[0].type !== 'ArrowFunctionExpression') {
	          return context.report({ node: node, message: _javascript.EVAL_STRING_ARG.code });
	        }
	      }
	    }
	  };
	}

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.event_listener_fourth = event_listener_fourth;
	
	var _javascript = __webpack_require__(24);
	
	var _utils = __webpack_require__(6);
	
	function event_listener_fourth(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      var referenceNode = (0, _utils.getNodeReference)(context, node.callee);
	      if (typeof referenceNode.property !== 'undefined' && referenceNode.property.type === 'Identifier' && referenceNode.property.name === 'addEventListener') {
	
	        if (node.arguments.length > 3) {
	          var wantsUntrusted = node.arguments[3];
	          switch (wantsUntrusted.type) {
	            case 'Literal':
	              if (wantsUntrusted.value) {
	                return context.report({
	                  node: node,
	                  message: _javascript.EVENT_LISTENER_FOURTH.code
	                });
	              }
	              break;
	            case 'Identifier':
	              referenceNode = (0, _utils.getNodeReference)(context, wantsUntrusted);
	              if (referenceNode.value) {
	                return context.report({
	                  node: node,
	                  message: _javascript.EVENT_LISTENER_FOURTH.code
	                });
	              }
	              break;
	          }
	        }
	      }
	    }
	  };
	}

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.global_require_arg = global_require_arg;
	
	var _messages = __webpack_require__(20);
	
	var _utils = __webpack_require__(6);
	
	/*
	 * This rule will detect a global passed to `require()` as the first arg
	 *
	 */
	function global_require_arg(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      if (node.callee.name === 'require' && node.arguments && node.arguments.length) {
	        var firstArg = node.arguments[0];
	        if (firstArg.type === 'Identifier') {
	          var pathVar = (0, _utils.getVariable)(context, firstArg.name);
	          if (typeof pathVar === 'undefined') {
	            // We infer this is probably a global.
	            return context.report(node, _messages.UNEXPECTED_GLOGAL_ARG.code);
	          }
	        }
	      }
	    }
	  };
	}

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.init_null_arg = init_null_arg;
	
	var _javascript = __webpack_require__(24);
	
	var _utils = __webpack_require__(6);
	
	function init_null_arg(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      // Check if what's being called is nsiTransferable.init()
	      if (typeof node.callee !== 'undefined') {
	        var nodeReference = (0, _utils.getNodeReference)(context, node.callee);
	        var nodeObject = (0, _utils.getNodeReference)(context, nodeReference.object);
	
	        if (nodeObject === undefined) {
	          return;
	        }
	        if (nodeObject.name === 'nsITransferable' && nodeReference.property.name === 'init') {
	
	          if (node.arguments.length > 0) {
	            // Get the reference to the first arg and check if it's null.
	            var arg = (0, _utils.getNodeReference)(context, node.arguments[0]);
	            if (arg.value === null) {
	              return context.report({ node: node, message: _javascript.INIT_NULL_ARG.code });
	            }
	          }
	        }
	      }
	    }
	  };
	}

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.low_level_module = low_level_module;
	
	var _const = __webpack_require__(9);
	
	var _messages = __webpack_require__(20);
	
	var _utils = __webpack_require__(6);
	
	/*
	 * This rule will detect use of `require()` with the first arg being either
	 * a literal that matches a restricted module or a var pointing to a literal
	 * that matches a restricted value.
	 *
	 * TODO: This rule should only be run for jetpack.
	 * TODO: Check what the requires_chrome feature does in the old code.
	 *
	 */
	function low_level_module(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      var requiresLowLevelMod = false;
	      if (node.callee.name === 'require' && node.arguments && node.arguments.length) {
	
	        var firstArg = node.arguments[0];
	
	        // Find a literal string value passed to the
	        // the require function.
	        if (firstArg.type === 'Literal' && _const.LOW_LEVEL_MODULES.includes(firstArg.value)) {
	          requiresLowLevelMod = true;
	        }
	
	        // Detect a var matching the widget module
	        // being passed as the first arg of require().
	        if (firstArg.type === 'Identifier') {
	          var pathVar = (0, _utils.getVariable)(context, firstArg.name);
	          if (pathVar && pathVar.type === 'Literal' && _const.LOW_LEVEL_MODULES.includes(pathVar.value)) {
	            requiresLowLevelMod = true;
	          }
	        }
	
	        if (requiresLowLevelMod) {
	          return context.report(node, _messages.LOW_LEVEL_MODULE.code);
	        }
	      }
	    }
	  };
	}

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.mozindexeddb = mozindexeddb;
	
	var _messages = __webpack_require__(20);
	
	function mozindexeddb(context) {
	  return {
	    Identifier: function Identifier(node) {
	      // Catches `var foo = mozIndexedDB;`.
	      if (node.name === 'mozIndexedDB' && node.parent.type !== 'MemberExpression') {
	        return context.report(node, _messages.MOZINDEXEDDB.code);
	      }
	    }
	  };
	}

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.mozindexeddb_property = mozindexeddb_property;
	
	var _messages = __webpack_require__(20);
	
	function mozindexeddb_property(context) {
	  return {
	    Identifier: function Identifier(node) {
	      // Catches `var foo = 'mozIndexedDB'; var myDatabase = window[foo];`.
	      if (node.parent.init && node.parent.init.value === 'mozIndexedDB') {
	        return context.report(node, _messages.MOZINDEXEDDB_PROPERTY.code);
	      }
	    },
	    MemberExpression: function MemberExpression(node) {
	      // Catches `var foo = window.mozIndexedDB;` and
	      // `var foo = window['mozIndexedDB'];`.
	      if (node.property.name === 'mozIndexedDB' || node.property.value === 'mozIndexedDB') {
	        context.report(node, _messages.MOZINDEXEDDB_PROPERTY.code);
	      }
	    }
	  };
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.only_prefs_in_defaults = only_prefs_in_defaults;
	
	var _javascript = __webpack_require__(24);
	
	var _utils = __webpack_require__(6);
	
	function only_prefs_in_defaults(context) {
	  var filename = context.getFilename();
	
	  // This rule only applies to files in defaults/preferences
	  if (filename.indexOf('defaults/preferences/') === 0) {
	    return {
	      CallExpression: function CallExpression(node) {
	        var root = (0, _utils.getRootExpression)(node);
	
	        if (root.name !== 'pref' && root.name !== 'user_pref') {
	          return context.report(node, _javascript.ONLY_PREFS_IN_DEFAULTS.code);
	        }
	      }
	    };
	  } else {
	    return {};
	  }
	}

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.opendialog_nonlit_uri = opendialog_nonlit_uri;
	
	var _messages = __webpack_require__(20);
	
	function opendialog_nonlit_uri(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      if (node.callee.type === 'MemberExpression' && node.callee.property.type === 'Identifier' && node.callee.property.name === 'openDialog') {
	
	        if (node.arguments.length) {
	          var uri = node.arguments[0];
	          if (uri.type !== 'Literal') {
	            return context.report(node, _messages.OPENDIALOG_NONLIT_URI.code);
	          }
	        }
	      }
	    }
	  };
	}

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.opendialog_remote_uri = opendialog_remote_uri;
	
	var _utils = __webpack_require__(6);
	
	var _messages = __webpack_require__(20);
	
	function opendialog_remote_uri(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      if (node.callee.type === 'MemberExpression' && node.callee.property.type === 'Identifier' && node.callee.property.name === 'openDialog') {
	
	        if (node.arguments.length) {
	          var uri = node.arguments[0];
	          if (uri.type === 'Literal' && (0, _utils.isLocalUrl)(uri.value) === false) {
	            return context.report(node, _messages.OPENDIALOG_REMOTE_URI.code);
	          }
	        }
	      }
	    }
	  };
	}

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shallow_wrapper = shallow_wrapper;
	
	var _messages = __webpack_require__(20);
	
	// This rule is used for older add-ons (non-Jetpack I believe) but honestly
	// it is a bit unclear as the MDN docs on XPCNativeWrapper seem to have moved
	// to XRay: https://developer.mozilla.org/en-US/docs/Xray_vision
	//
	// TODO: Find out more about this rule.
	function shallow_wrapper(context) {
	  function _testForShallowWrapper(node) {
	    if (node.callee.name === 'XPCNativeWrapper' && node.callee.type === 'Identifier') {
	
	      if (node.arguments[0].type === 'Identifier' || node.arguments[0].type === 'MemberExpression') {
	        return context.report(node, _messages.SHALLOW_WRAPPER.code);
	      }
	    }
	  }
	
	  return {
	    CallExpression: _testForShallowWrapper,
	    NewExpression: _testForShallowWrapper
	  };
	}

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.webextension_api = webextension_api;
	
	var _const = __webpack_require__(9);
	
	var _utils = __webpack_require__(6);
	
	function webextension_api(context) {
	  return {
	    MemberExpression: function MemberExpression(node) {
	      if (node.object.object && ['chrome', 'browser'].includes(node.object.object.name)) {
	        var api = node.object.property.name + '.' + node.property.name;
	
	        if (_const.DEPRECATED_APIS.includes(api)) {
	          return context.report(node, (0, _utils.apiToMessage)(api));
	        }
	
	        if (!context.settings.addonMetadata.id && _const.TEMPORARY_APIS.includes(api)) {
	          return context.report(node, (0, _utils.apiToMessage)(api));
	        }
	      }
	    }
	  };
	}

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.widget_module = widget_module;
	
	var _messages = __webpack_require__(20);
	
	var _utils = __webpack_require__(6);
	
	var WIDGET_PATH = 'sdk/widget';
	
	/*
	 * This rule will detect use of `require()` with the first arg being either
	 * a literal that matches the widget module or var pointing at a literal.
	 *
	 * TODO: This rule looks to be related to compat - based on the old tests.
	 * TODO: This rule should only be run for jetpack.
	 *
	 */
	function widget_module(context) {
	  return {
	    CallExpression: function CallExpression(node) {
	      var requiresWidgetMod = false;
	      if (node.callee.name === 'require' && node.arguments && node.arguments.length) {
	
	        var firstArg = node.arguments[0];
	
	        // Find a literal string value passed to the
	        // the require function.
	        if (firstArg.type === 'Literal' && firstArg.value === WIDGET_PATH) {
	          requiresWidgetMod = true;
	        }
	
	        // Detect a var matching the widget module
	        // being passed as the first arg of require().
	        if (firstArg.type === 'Identifier') {
	          var pathVar = (0, _utils.getVariable)(context, firstArg.name);
	          if (pathVar && pathVar.type === 'Literal' && pathVar.value === WIDGET_PATH) {
	            requiresWidgetMod = true;
	          }
	        }
	
	        if (requiresWidgetMod) {
	          return context.report(node, _messages.DEPREC_SDK_MOD_WIDGET.code);
	        }
	      }
	    }
	  };
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _json = __webpack_require__(39);
	
	var _json2 = _interopRequireDefault(_json);
	
	var _base = __webpack_require__(42);
	
	var _base2 = _interopRequireDefault(_base);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var JSONScanner = function (_BaseScanner) {
	  _inherits(JSONScanner, _BaseScanner);
	
	  function JSONScanner() {
	    _classCallCheck(this, JSONScanner);
	
	    return _possibleConstructorReturn(this, (JSONScanner.__proto__ || Object.getPrototypeOf(JSONScanner)).apply(this, arguments));
	  }
	
	  _createClass(JSONScanner, [{
	    key: '_getContents',
	    value: function _getContents() {
	      return Promise.resolve(this.contents);
	    }
	  }, {
	    key: 'scan',
	    value: function scan() {
	      var _this2 = this;
	
	      return this.getContents().then(function (json) {
	        var jsonParser = new _json2.default(json, _this2.options.collector, {
	          filename: _this2.filename });
	        jsonParser.parse();
	        return Promise.resolve([]);
	      }).catch(function (err) {
	        return Promise.reject(err);
	      });
	    }
	  }]);
	
	  return JSONScanner;
	}(_base2.default);
	
	exports.default = JSONScanner;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _xmldom = __webpack_require__(77);
	
	var _xmldom2 = _interopRequireDefault(_xmldom);
	
	var _const = __webpack_require__(9);
	
	var _base = __webpack_require__(42);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _rdf = __webpack_require__(78);
	
	var rules = _interopRequireWildcard(_rdf);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var RDFScanner = function (_BaseScanner) {
	  _inherits(RDFScanner, _BaseScanner);
	
	  function RDFScanner(contents, filename) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	    _classCallCheck(this, RDFScanner);
	
	    // I don't think this ever needs to be different, but if it does we can
	    // extract the em namespace using:
	    //
	    //     this.namespace = this._xmlDoc.documentElement._nsMap.em;
	    //
	    // Inside _getContents.
	    var _this = _possibleConstructorReturn(this, (RDFScanner.__proto__ || Object.getPrototypeOf(RDFScanner)).call(this, contents, filename, options));
	
	    _this._defaultRules = rules;
	    if (typeof _this.options.namespace === 'undefined') {
	      _this.options.namespace = _const.RDF_DEFAULT_NAMESPACE;
	    }
	    return _this;
	  }
	
	  _createClass(RDFScanner, [{
	    key: '_getContents',
	    value: function _getContents() {
	      var _this2 = this;
	
	      return new Promise(function (resolve, reject) {
	        var xmlDoc = new _xmldom2.default.DOMParser({
	          errorHandler: function errorHandler(err) {
	            reject(new Error('RDFParseError: ' + err));
	          }
	        }).parseFromString(_this2.contents, 'text/xml');
	
	        resolve(xmlDoc);
	      });
	    }
	  }]);
	
	  return RDFScanner;
	}(_base2.default);
	
	exports.default = RDFScanner;

/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = require("xmldom");

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _mustNotExist = __webpack_require__(79);
	
	Object.keys(_mustNotExist).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _mustNotExist[key];
	    }
	  });
	});

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.mustNotExist = mustNotExist;
	exports._checkForTags = _checkForTags;
	
	var _const = __webpack_require__(9);
	
	var _messages = __webpack_require__(20);
	
	var messages = _interopRequireWildcard(_messages);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function mustNotExist(xmlDoc, filename) {
	  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	      namespace = _ref.namespace;
	
	  return new Promise(function (resolve) {
	    var bannedTags = _const.RDF_UNALLOWED_TAGS;
	    var linterMessages = [];
	
	    var addonIsListed = xmlDoc.getElementsByTagNameNS(namespace, 'listed').length > 0;
	
	    if (addonIsListed) {
	      bannedTags = bannedTags.concat(_const.RDF_UNALLOWED_IF_LISTED_TAGS);
	    }
	
	    // Using any banned tag is an error.
	    linterMessages = linterMessages.concat(_checkForTags({
	      xmlDoc: xmlDoc,
	      namespace: namespace,
	      tags: bannedTags,
	      type: _const.VALIDATION_ERROR,
	      prefix: 'TAG_NOT_ALLOWED_',
	      filename: filename
	    }));
	
	    // But using an obsolete tag is just a warning.
	    linterMessages = linterMessages.concat(_checkForTags({
	      xmlDoc: xmlDoc,
	      namespace: namespace,
	      tags: _const.RDF_OBSOLETE_TAGS,
	      type: _const.VALIDATION_WARNING,
	      prefix: 'TAG_OBSOLETE_',
	      filename: filename
	    }));
	
	    resolve(linterMessages);
	  });
	}
	
	function _checkForTags() {
	  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      xmlDoc = _ref2.xmlDoc,
	      namespace = _ref2.namespace,
	      tags = _ref2.tags,
	      type = _ref2.type,
	      prefix = _ref2.prefix,
	      filename = _ref2.filename;
	
	  var linterMessages = [];
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var tag = _step.value;
	
	      var nodeList = xmlDoc.getElementsByTagNameNS(namespace, tag);
	
	      for (var i = 0; i < nodeList.length; i++) {
	        var element = nodeList.item(i);
	        var errorCode = '' + prefix + tag.toUpperCase();
	
	        linterMessages.push({
	          code: errorCode,
	          message: messages[errorCode].message,
	          description: messages[errorCode].description,
	          sourceCode: '<' + tag + '>', // Don't really know what to use here.
	          file: filename,
	          line: element.line,
	          column: element.column,
	          type: type
	        });
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return linterMessages;
	}

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _crx = __webpack_require__(81);
	
	Object.keys(_crx).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _crx[key];
	    }
	  });
	});
	
	var _directory = __webpack_require__(88);
	
	Object.keys(_directory).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _directory[key];
	    }
	  });
	});
	
	var _xpi = __webpack_require__(84);
	
	Object.keys(_xpi).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _xpi[key];
	    }
	  });
	});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Crx = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _fs2 = __webpack_require__(17);
	
	var _fs3 = _interopRequireDefault(_fs2);
	
	var _crxParser = __webpack_require__(82);
	
	var _crxParser2 = _interopRequireDefault(_crxParser);
	
	var _yauzl = __webpack_require__(83);
	
	var _yauzl2 = _interopRequireDefault(_yauzl);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _xpi = __webpack_require__(84);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/*
	 * A CRX file is just a ZIP file (eg an XPI) with some extra header
	 * information. So we handle opening the file with a CRX parser, then treat
	 * it like an XPI after that.
	 *
	 */
	var Crx = exports.Crx = function (_Xpi) {
	  _inherits(Crx, _Xpi);
	
	  function Crx(filePath) {
	    var zipLib = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _yauzl2.default;
	
	    var _parseCRX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _crxParser2.default;
	
	    var _fs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _fs3.default;
	
	    _classCallCheck(this, Crx);
	
	    var _this = _possibleConstructorReturn(this, (Crx.__proto__ || Object.getPrototypeOf(Crx)).call(this, filePath, zipLib));
	
	    _this.fs = _fs;
	    _this.parseCRX = _parseCRX;
	    return _this;
	  }
	
	  _createClass(Crx, [{
	    key: 'open',
	    value: function open() {
	      var _this2 = this;
	
	      return new Promise(function (resolve, reject) {
	        // First, read the file manually, as we need to pass the whole thing
	        // to crx-parser.
	        _this2.fs.readFile(_this2.path, function (err, buffer) {
	          if (err) {
	            return reject(err);
	          }
	          // Parse out the CRX header data from the actual ZIP contents.
	          _this2.parseCRX(buffer, function (err, data) {
	            if (err) {
	              return reject(err);
	            }
	
	            _logger2.default.debug('Obtained zip data from CRX file', data);
	            // Finally we can read in the zip data as a buffer into yauzl.
	            _this2.zipLib.fromBuffer(data.body, function (err, zipFile) {
	              if (err) {
	                return reject(err);
	              }
	
	              resolve(zipFile);
	            });
	          });
	        });
	      });
	    }
	  }, {
	    key: 'getFiles',
	    value: function getFiles(_onEventsSubscribed) {
	      var _this3 = this;
	
	      return new Promise(function (resolve, reject) {
	        // If we have already processed the file and have data
	        // on this instance return that.
	        if (Object.keys(_this3.files).length) {
	          return resolve(_this3.files);
	        }
	
	        return _this3.open().then(function (zipfile) {
	
	          zipfile.on('entry', function (entry) {
	            _this3.handleEntry(entry, reject);
	          });
	
	          // We use the 'end' event here because we're reading the CRX in
	          // from a buffer (because we have to unpack the header info from it
	          // first). The 'close' event is never fired when using yauzl's
	          // `fromBuffer()` method.
	          zipfile.on('end', function () {
	            resolve(_this3.files);
	          });
	
	          if (_onEventsSubscribed) {
	            // Run optional callback when we know the event handlers
	            // have been inited. Useful for testing.
	            if (typeof _onEventsSubscribed === 'function') {
	              _onEventsSubscribed();
	            }
	          }
	        }).catch(reject);
	      });
	    }
	  }]);

	  return Crx;
	}(_xpi.Xpi);

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = require("crx-parser");

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = require("yauzl");

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Xpi = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['DuplicateZipEntry: Entry\n        "', '" has already been seen'], ['DuplicateZipEntry: Entry\n        "', '" has already been seen']);
	
	var _yauzl = __webpack_require__(83);
	
	var _yauzl2 = _interopRequireDefault(_yauzl);
	
	var _stripBomStream = __webpack_require__(85);
	
	var _stripBomStream2 = _interopRequireDefault(_stripBomStream);
	
	var _firstChunkStream = __webpack_require__(86);
	
	var _firstChunkStream2 = _interopRequireDefault(_firstChunkStream);
	
	var _base = __webpack_require__(87);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _utils = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/*
	 * Simple Promise wrapper for the Yauzl unzipping lib to unpack add-on .xpis.
	 * Note: We're using the autoclose feature of yauzl as a result every operation
	 * will open the zip, do something and then close it implicitly.
	 * This makes the API easy to use and the consumer doesn't need to remember to
	 * close the zipfile.
	 *
	 */
	
	var Xpi = exports.Xpi = function (_IOBase) {
	  _inherits(Xpi, _IOBase);
	
	  function Xpi(filePath) {
	    var zipLib = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _yauzl2.default;
	
	    _classCallCheck(this, Xpi);
	
	    var _this = _possibleConstructorReturn(this, (Xpi.__proto__ || Object.getPrototypeOf(Xpi)).call(this, filePath));
	
	    _this.zipLib = zipLib;
	    return _this;
	  }
	
	  _createClass(Xpi, [{
	    key: 'open',
	    value: function open() {
	      var _this2 = this;
	
	      return new Promise(function (resolve, reject) {
	        _this2.zipLib.open(_this2.path, function (err, zipfile) {
	          if (err) {
	            return reject(err);
	          }
	          resolve(zipfile);
	        });
	      });
	    }
	  }, {
	    key: 'handleEntry',
	    value: function handleEntry(entry, reject) {
	      if (/\/$/.test(entry.fileName)) {
	        return;
	      }
	      if (!this.shouldScanFile(entry.fileName)) {
	        _logger2.default.debug('Skipping file: ' + entry.fileName);
	        return;
	      }
	      if (this.entries.includes(entry.fileName)) {
	        _logger2.default.info('Found duplicate file entry: "%s" in package', entry.fileName);
	        reject(new Error((0, _utils.singleLineString)(_templateObject, entry.fileName)));
	      }
	      this.entries.push(entry.fileName);
	      this.files[entry.fileName] = entry;
	    }
	  }, {
	    key: 'getFiles',
	    value: function getFiles(_onEventsSubscribed) {
	      var _this3 = this;
	
	      return new Promise(function (resolve, reject) {
	        // If we have already processed the file and have data
	        // on this instance return that.
	        if (Object.keys(_this3.files).length) {
	          var _ret = function () {
	            var wantedFiles = {};
	            Object.keys(_this3.files).forEach(function (fileName) {
	              if (_this3.shouldScanFile(fileName)) {
	                wantedFiles[fileName] = _this3.files[fileName];
	              } else {
	                _logger2.default.debug('Skipping cached file: ' + fileName);
	              }
	            });
	            return {
	              v: resolve(wantedFiles)
	            };
	          }();
	
	          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	        }
	
	        return _this3.open().then(function (zipfile) {
	
	          zipfile.on('entry', function (entry) {
	            _this3.handleEntry(entry, reject);
	          });
	
	          // When the last entry has been processed
	          // and the fd is closed resolve the promise.
	          // Note: we cannot use 'end' here as 'end' is fired
	          // after the last entry event is emitted and streams
	          // may still be being read with openReadStream.
	          zipfile.on('close', function () {
	            resolve(_this3.files);
	          });
	
	          if (_onEventsSubscribed) {
	            // Run optional callback when we know the event handlers
	            // have been inited. Useful for testing.
	            if (typeof _onEventsSubscribed === 'function') {
	              _onEventsSubscribed();
	            }
	          }
	        }).catch(reject);
	      });
	    }
	  }, {
	    key: 'checkPath',
	    value: function checkPath(path) {
	      if (!this.files.hasOwnProperty(path)) {
	        throw new Error('Path "' + path + '" does not exist in this XPI');
	      }
	
	      if (this.files[path].uncompressedSize > this.maxSizeBytes) {
	        throw new Error('File "' + path + '" is too large. Aborting.');
	      }
	    }
	  }, {
	    key: 'getFileAsStream',
	    value: function getFileAsStream(path) {
	      var _this4 = this;
	
	      return new Promise(function (resolve, reject) {
	        _this4.checkPath(path);
	        return _this4.open().then(function (zipfile) {
	          zipfile.openReadStream(_this4.files[path], function (err, readStream) {
	            if (err) {
	              return reject(err);
	            }
	            resolve(readStream.pipe((0, _stripBomStream2.default)()));
	          });
	        }).catch(reject);
	      });
	    }
	  }, {
	    key: 'getFileAsString',
	    value: function getFileAsString(path) {
	      return this.getFileAsStream(path).then(function (fileStream) {
	        return new Promise(function (resolve, reject) {
	          var fileString = '';
	          fileStream.on('data', function (chunk) {
	            fileString += chunk;
	          });
	
	          // Once the file is assembled, resolve the promise.
	          fileStream.on('end', function () {
	            resolve(fileString);
	          });
	
	          fileStream.on('error', reject);
	        });
	      });
	    }
	  }, {
	    key: 'getChunkAsBuffer',
	    value: function getChunkAsBuffer(path, chunkLength) {
	      var _this5 = this;
	
	      return new Promise(function (resolve, reject) {
	        _this5.checkPath(path);
	        return _this5.open().then(function (zipfile) {
	          zipfile.openReadStream(_this5.files[path], function (err, readStream) {
	            if (err) {
	              return reject(err);
	            }
	            readStream.pipe((0, _firstChunkStream2.default)({ chunkLength: chunkLength }, function (_, enc) {
	              resolve(enc);
	            }));
	          });
	        }).catch(reject);
	      });
	    }
	  }]);

	  return Xpi;
	}(_base.IOBase);

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = require("strip-bom-stream");

/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = require("first-chunk-stream");

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IOBase = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['Unexpected fileStreamType\n          value "', '" should be one of "string",\n          "stream" or "chunk"'], ['Unexpected fileStreamType\n          value "', '" should be one of "string",\n          "stream" or "chunk"']);
	
	var _utils = __webpack_require__(6);
	
	var _const = __webpack_require__(9);
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/*
	 * Base class for io operations for both an Xpi or
	 * a directory
	 */
	var IOBase = exports.IOBase = function () {
	  function IOBase(packageOrDirPath) {
	    _classCallCheck(this, IOBase);
	
	    this.path = packageOrDirPath;
	    this.files = {};
	    this.entries = [];
	    // If this is too large the node process will hit a RangeError
	    // when it runs out of memory.
	    this.maxSizeBytes = 1024 * 1024 * _const.MAX_FILE_SIZE_MB;
	    // A callback that accepts a relative file path and returns
	    // true if the path should be included in results for scanning.
	    this.shouldScanFile = function () {
	      return true;
	    };
	  }
	
	  _createClass(IOBase, [{
	    key: 'setScanFileCallback',
	    value: function setScanFileCallback(callback) {
	      if (typeof callback === 'function') {
	        this.shouldScanFile = callback;
	      }
	    }
	  }, {
	    key: 'getFile',
	    value: function getFile(path) {
	      var fileStreamType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'string';
	
	      switch (fileStreamType) {
	        case 'stream':
	          return this.getFileAsStream(path);
	        case 'string':
	          return this.getFileAsString(path);
	        case 'chunk':
	          // Assuming that chunk is going to be primarily used for finding magic
	          // numbers in files, then there's no need to have the default be longer
	          // than that.
	          return this.getChunkAsBuffer(path, _const.FLAGGED_FILE_MAGIC_NUMBERS_LENGTH);
	
	        default:
	          throw new Error((0, _utils.singleLineString)(_templateObject, fileStreamType));
	      }
	    }
	  }, {
	    key: 'getFilesByExt',
	    value: function getFilesByExt() {
	      for (var _len = arguments.length, extensions = Array(_len), _key = 0; _key < _len; _key++) {
	        extensions[_key] = arguments[_key];
	      }
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	
	        for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var ext = _step.value;
	
	          if (ext.indexOf('.') !== 0) {
	            // We use Promise.reject as we're not inside a `then()` or a
	            // Promise constructor callback.
	            // If we throw here it won't be caught.
	            return Promise.reject(new Error("File extension must start with '.'"));
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return this.getFiles().then(function (filesObject) {
	        var files = [];
	
	        for (var filename in filesObject) {
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;
	
	          try {
	            for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var ext = _step2.value;
	
	              if (filename.endsWith(ext)) {
	                files.push(filename);
	              }
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }
	        }
	
	        return files;
	      });
	    }
	  }, {
	    key: 'getFiles',
	    value: function getFiles() {
	      return Promise.reject(new Error('getFiles is not implemented'));
	    }
	  }, {
	    key: 'getFileAsStream',
	    value: function getFileAsStream() {
	      return Promise.reject(new Error('getFileAsStream is not implemented'));
	    }
	  }, {
	    key: 'getFileAsString',
	    value: function getFileAsString() {
	      return Promise.reject(new Error('getFileAsString is not implemented'));
	    }
	  }, {
	    key: 'getChunkAsBuffer',
	    value: function getChunkAsBuffer() {
	      return Promise.reject(new Error('getChunkAsBuffer is not implemented'));
	    }
	  }]);

	  return IOBase;
	}();

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Directory = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _templateObject = _taggedTemplateLiteral(['Files already exist for directory\n               "', '" returning cached data'], ['Files already exist for directory\n               "', '" returning cached data']);
	
	var _path = __webpack_require__(12);
	
	var path = _interopRequireWildcard(_path);
	
	var _fs = __webpack_require__(17);
	
	var _firstChunkStream = __webpack_require__(86);
	
	var _firstChunkStream2 = _interopRequireDefault(_firstChunkStream);
	
	var _stripBomStream = __webpack_require__(85);
	
	var _stripBomStream2 = _interopRequireDefault(_stripBomStream);
	
	var _base = __webpack_require__(87);
	
	var _utils = __webpack_require__(16);
	
	var _utils2 = __webpack_require__(6);
	
	var _logger = __webpack_require__(4);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Directory = exports.Directory = function (_IOBase) {
	  _inherits(Directory, _IOBase);
	
	  function Directory() {
	    _classCallCheck(this, Directory);
	
	    return _possibleConstructorReturn(this, (Directory.__proto__ || Object.getPrototypeOf(Directory)).apply(this, arguments));
	  }
	
	  _createClass(Directory, [{
	    key: 'getFiles',
	    value: function getFiles() {
	      var _this2 = this;
	
	      var _walkPromise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _utils.walkPromise;
	
	      // If we have already processed this directory and have data
	      // on this instance return that.
	      if (Object.keys(this.files).length) {
	        _logger2.default.info((0, _utils2.singleLineString)(_templateObject, this.path));
	        return Promise.resolve(this.files);
	      }
	
	      return _walkPromise(this.path, {
	        shouldIncludePath: function shouldIncludePath() {
	          return _this2.shouldScanFile.apply(_this2, arguments);
	        }
	      }).then(function (files) {
	        _this2.files = files;
	        _this2.entries = Object.keys(files);
	        return files;
	      });
	    }
	  }, {
	    key: 'getPath',
	    value: function getPath(relativeFilePath) {
	      if (!this.files.hasOwnProperty(relativeFilePath)) {
	        return Promise.reject(new Error('Path "' + relativeFilePath + '" does not exist in this dir.'));
	      }
	
	      if (this.files[relativeFilePath].size > this.maxSizeBytes) {
	        return Promise.reject(new Error('File "' + relativeFilePath + '" is too large. Aborting'));
	      }
	
	      var absoluteDirPath = path.resolve(this.path);
	      var filePath = path.resolve(path.join(absoluteDirPath, relativeFilePath));
	
	      // This is belt and braces. Should never happen that a file was in
	      // the files object and yet doesn't meet these requirements.
	      if (!filePath.startsWith(absoluteDirPath) || relativeFilePath.startsWith('/')) {
	        return Promise.reject(new Error('Path argument must be relative to ' + this.path));
	      }
	
	      return Promise.resolve(filePath);
	    }
	  }, {
	    key: 'getFileAsStream',
	    value: function getFileAsStream(relativeFilePath) {
	      return this.getPath(relativeFilePath).then(function (filePath) {
	        return Promise.resolve((0, _fs.createReadStream)(filePath, {
	          flags: 'r',
	          encoding: 'utf8',
	          autoClose: true
	        }).pipe((0, _stripBomStream2.default)()));
	      });
	    }
	  }, {
	    key: 'getFileAsString',
	    value: function getFileAsString(path) {
	      return this.getFileAsStream(path).then(function (readStream) {
	        return new Promise(function (resolve, reject) {
	          var content = '';
	          readStream.on('readable', function () {
	            var chunk;
	            while (null !== (chunk = readStream.read())) {
	              content += chunk.toString();
	            }
	          });
	
	          readStream.on('end', function () {
	            resolve(content);
	          });
	
	          readStream.on('error', reject);
	        });
	      });
	    }
	  }, {
	    key: 'getChunkAsBuffer',
	    value: function getChunkAsBuffer(relativeFilePath, chunkLength) {
	      return this.getPath(relativeFilePath).then(function (filePath) {
	        return new Promise(function (resolve) {
	          (0, _fs.createReadStream)(filePath, {
	            flags: 'r',
	            // This is important because you don't want to encode the
	            // bytes if you are doing a binary check.
	            encoding: null,
	            autoClose: true
	          }).pipe((0, _firstChunkStream2.default)({ chunkLength: chunkLength }, function (_, enc) {
	            resolve(enc);
	          }));
	        });
	      });
	    }
	  }]);

	  return Directory;
	}(_base.IOBase);

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = require("babel-polyfill");

/***/ }
/******/ ]);
//# sourceMappingURL=addons-linter.js.map